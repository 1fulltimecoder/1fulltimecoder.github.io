<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Binary Search Template | Samir Paul</title>
<meta name=keywords content="Binary Search Template,Coding blog,Computer Science"><meta name=description content="Binary Search Template"><meta name=author content="Samir Paul"><link rel=canonical href=https://samirpaulb.github.io/posts/binary-search-template/><meta name=google-site-verification content="vJAOBxbJTCK2vXG-hLFeGsoC9hXgFlCpuJJ8AcJLROQ"><meta name=yandex-verification content="fe6a06c57be84984"><meta name=msvalidate.01 content="1A92FC2EC113F8616A21D76DA684A133"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://samirpaulb.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://samirpaulb.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://samirpaulb.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://samirpaulb.github.io/apple-touch-icon.png><link rel=mask-icon href=https://samirpaulb.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=manifest href=/manifest.json><link rel=sitemap type=application/xml title=Sitemap href=https://samirpaulb.github.io/sitemap.xml><link rel=alternate type=application/rss+xml title=RSS href=https://samirpaulb.github.io/index.xml><meta content="@SamirPaulb" name=twitter:site><meta content="@SamirPaulb" name=twitter:creator><meta content="24bac6e1fbf1750de40d59bb788d9dd9" name=p:domain_verify><meta content="6800281970014175" property="fb:app_id"><meta content="3pkgruuk3kzlsn3jdfehgbd4sem1qb" name=facebook-domain-verification><meta content="n93bHAYCJyRzj_9ccNNLKYUj03U0eWuhdV5Gb-bv2_g" name=google-site-verification><meta name=google-site-verification content="uziThFIJ1huzKLCKv-DChPbWZTRRFqmmdA6pcA-dqzs"><meta content="2xno70lnqo1ajcykeat10qud6lat0xlkc2bskxz0k9ma74g0bn-kprra5ev6bwui2s6-2394l0ryopjet7yt3hs8tokilug2cfhocw3r0nlj2t1xx690tgu82t59wtwi" name=norton-safeweb-site-verification><meta content="NHI3em00K1U3WmRGTTRHeWVGNUdNZz090" name=dmca-site-verification><link href=//fonts.googleapis.com rel='preconnect dns-prefetch'><link href=//storage.googleapis.com rel='preconnect dns-prefetch'><link href=//use.fontawesome.com rel='preconnect dns-prefetch'><link href=//ajax.googleapis.com rel='preconnect dns-prefetch'><link href=//ajax.microsoft.com rel='preconnect dns-prefetch'><link href=//github.com rel='preconnect dns-prefetch'><link href=//cdnjs.cloudflare.com rel='preconnect dns-prefetch'><link href=//www.google-analytics.com rel='preconnect dns-prefetch'><link href=//pagead2.googlesyndication.com rel='preconnect dns-prefetch'><link href=//googleads.g.doubleclick.net rel='preconnect dns-prefetch'><link href=//www.gstatic.com rel='preconnect dns-prefetch'><link href=//www.googletagmanager.com rel='preconnect dns-prefetch'><link href=//www.googletagservices.com rel='preconnect dns-prefetch'><link href=//static.xx.fbcdn.net rel='preconnect dns-prefetch'><link href=//tpc.googlesyndication.com rel='preconnect dns-prefetch'><link href=//apis.google.com rel='preconnect dns-prefetch'><link href=//www.w3.org rel='preconnect dns-prefetch'><link href=//www.facebook.com rel='preconnect dns-prefetch'><link href=//connect.facebook.net rel='preconnect dns-prefetch'><link href=//disqus.com rel='preconnect dns-prefetch'><link href=//samirpaul.disqus.com rel='preconnect dns-prefetch'><link href=//www.youtube.com rel='preconnect dns-prefetch'><link href=//img.youtube.com rel='preconnect dns-prefetch'><link href=//www.pinterest.com rel='preconnect dns-prefetch'><link href=//www.linkedin.com rel='preconnect dns-prefetch'><link href=//player.vimeo.com rel='preconnect dns-prefetch'><link href=//amazonaws.com rel='preconnect dns-prefetch'><link href=//s3.amazonaws.com rel='preconnect dns-prefetch'><link href=//s3.buysellads.com rel='preconnect dns-prefetch'><link href=//stats.buysellads.com rel='preconnect dns-prefetch'><link href=//scdn.netlify.app rel='preconnect dns-prefetch'><link href=//spcdn.pages.dev rel='preconnect dns-prefetch'><link href=//scdn.web.app rel='preconnect dns-prefetch'><link href=//user-images.githubusercontent.com rel='preconnect dns-prefetch'><link href=//raw.githubusercontent.com rel='preconnect dns-prefetch'><link href=//cdn.jsdelivr.net rel='preconnect dns-prefetch'><link href=//res.cloudinary.com rel='preconnect dns-prefetch'><link href=//cloudinary.com rel='preconnect dns-prefetch'><link href=//imgur.com rel='preconnect dns-prefetch'><link href=//i.imgur.com rel='preconnect dns-prefetch'><link href=//firebaseio.com rel='preconnect dns-prefetch'><link href=//translate.googleapis.com rel='preconnect dns-prefetch'><link href=//google.com rel='preconnect dns-prefetch'><link href=//analytics.google.com rel='preconnect dns-prefetch'><link href=//cse.google.com rel='preconnect dns-prefetch'><script async src="https://www.googletagmanager.com/gtag/js?id=G-CP4QE6ZEV0"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CP4QE6ZEV0",{anonymize_ip:!1})}</script><meta property="og:title" content="Binary Search Template"><meta property="og:description" content="Binary Search Template"><meta property="og:type" content="article"><meta property="og:url" content="https://samirpaulb.github.io/posts/binary-search-template/"><meta property="og:image" content="https://res.cloudinary.com/samirpaul/image/upload/w_1100,c_fit,co_rgb:FFFFFF,l_text:Arial_75_bold:Binary Search Template/og-image.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-20T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-20T00:00:00+00:00"><meta property="og:see_also" content="https://samirpaulb.github.io/posts/data-structures-and-algorithms-for-coding-interview/"><meta property="og:see_also" content="https://samirpaulb.github.io/posts/some-of-my-online-courses-certificates/"><meta property="og:see_also" content="https://samirpaulb.github.io/posts/operating-system-notes-for-placement/"><meta property="og:see_also" content="https://samirpaulb.github.io/posts/curated-list-of-project-based-tutorials/"><meta property="og:see_also" content="https://samirpaulb.github.io/posts/complete-computer-science-study-plan-to-become-a-software-engineer/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://res.cloudinary.com/samirpaul/image/upload/w_1100,c_fit,co_rgb:FFFFFF,l_text:Arial_75_bold:Binary Search Template/og-image.webp"><meta name=twitter:title content="Binary Search Template"><meta name=twitter:description content="Binary Search Template"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://samirpaulb.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Binary Search Template","item":"https://samirpaulb.github.io/posts/binary-search-template/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Binary Search Template","name":"Binary Search Template","description":"Binary Search Template","keywords":["Binary Search Template","Coding blog","Computer Science"],"articleBody":"Binary Search is quite easy to understand conceptually. Basically, it splits the search space into two halves and only keep the half that probably has the search target and throw away the other half that would not possibly have the answer. In this manner, we reduce the search space to half the size at every step, until we find the target. Binary Search helps us reduce the search time from linear O(n) to logarithmic O(log n). But when it comes to implementation, it’s rather difficult to write a bug-free code in just a few minutes. Some of the most common problems include:\nWhen to exit the loop? Should we use left \u003c right or left \u003c= right as the while loop condition? How to initialize the boundary variable left and right? How to update the boundary? How to choose the appropriate combination from left = mid, left = mid + 1 and right = mid, right = mid - 1? A rather common misunderstanding of binary search is that people often think this technique could only be used in simple scenario like “Given a sorted array, find a specific value in it”. As a matter of fact, it can be applied to much more complicated situations.\nAfter a lot of practice in LeetCode, I’ve made a powerful binary search template and solved many Hard problems by just slightly twisting this template. I’ll share the template with you guys in this post. I don’t want to just show off the code and leave. Most importantly, I want to share the logical thinking: how to apply this general template to all sorts of problems. Hopefully, after reading this post, people wouldn’t be pissed off any more when LeetCoding, “This problem could be solved with binary search! Why didn’t I think of that before!”\n\u003e\u003e Most Generalized Binary Search Suppose we have a search space. It could be an array, a range, etc. Usually it’s sorted in ascending order. For most tasks, we can transform the requirement into the following generalized form:\nMinimize k , s.t. condition(k) is True\nThe following code is the most generalized binary search template:\n1 2 3 4 5 6 7 8 9 10 11 12 def binary_search(array) -\u003e int: def condition(value) -\u003e bool: pass left, right = min(search_space), max(search_space) # could be [0, n], [1, n] etc. Depends on problem while left \u003c right: mid = left + (right - left) // 2 if condition(mid): right = mid else: left = mid + 1 return left What’s really nice of this template is that, for most of the binary search problems, we only need to modify three parts after copy-pasting this template, and never need to worry about corner cases and bugs in code any more:\nCorrectly initialize the boundary variables left and right to specify search space. Only one rule: set up the boundary to include all possible elements; Decide return value. Is it return left or return left - 1? Remember this: after exiting the while loop, left is the minimal k​ satisfying the condition function; Design the condition function. This is the most difficult and most beautiful part. Needs lots of practice. Below I’ll show you guys how to apply this powerful template to many LeetCode problems.\n\u003e\u003e Basic Application 278. First Bad Version [Easy] You are a product manager and currently leading a team to develop a new product. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad.\nExample:\n1 2 3 4 5 6 7 Given n = 5, and version = 4 is the first bad version. call isBadVersion(3) -\u003e false call isBadVersion(5) -\u003e true call isBadVersion(4) -\u003e true Then 4 is the first bad version. First, we initialize left = 1 and right = n to include all possible values. Then we notice that we don’t even need to design the condition function. It’s already given by the isBadVersion API. Finding the first bad version is equivalent to finding the minimal k satisfying isBadVersion(k) is True. Our template can fit in very nicely:\n1 2 3 4 5 6 7 8 9 10 class Solution: def firstBadVersion(self, n) -\u003e int: left, right = 1, n while left \u003c right: mid = left + (right - left) // 2 if isBadVersion(mid): right = mid else: left = mid + 1 return left 69. Sqrt(x) [Easy] Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.\nExample:\n1 2 Input: 4 Output: 2 1 2 Input: 8 Output: 2 Easy one. First we need to search for minimal k satisfying condition k^2 \u003e x, then k - 1 is the answer to the question. We can easily come up with the solution. Notice that I set right = x + 1 instead of right = x to deal with special input cases like x = 0 and x = 1.\n1 2 3 4 5 6 7 8 9 def mySqrt(x: int) -\u003e int: left, right = 0, x + 1 while left \u003c right: mid = left + (right - left) // 2 if mid * mid \u003e x: right = mid else: left = mid + 1 return left - 1 # `left` is the minimum k value, `k - 1` is the answer 35. Search Insert Position [Easy] Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.\nExample:\n1 2 Input: [1,3,5,6], 5 Output: 2 1 2 Input: [1,3,5,6], 2 Output: 1 Very classic application of binary search. We are looking for the minimal k value satisfying nums[k] \u003e= target, and we can just copy-paste our template. Notice that our solution is correct regardless of whether the input array nums has duplicates. Also notice that the input target might be larger than all elements in nums and therefore needs to placed at the end of the array. That’s why we should initialize right = len(nums) instead of right = len(nums) - 1.\n1 2 3 4 5 6 7 8 9 10 class Solution: def searchInsert(self, nums: List[int], target: int) -\u003e int: left, right = 0, len(nums) while left \u003c right: mid = left + (right - left) // 2 if nums[mid] \u003e= target: right = mid else: left = mid + 1 return left \u003e\u003e Advanced Application The above problems are quite easy to solve, because they already give us the array to be searched. We’d know that we should use binary search to solve them at first glance. However, more often are the situations where the search space and search target are not so readily available. Sometimes we won’t even realize that the problem should be solved with binary search – we might just turn to dynamic programming or DFS and get stuck for a very long time.\nAs for the question “When can we use binary search?”, my answer is that, If we can discover some kind of monotonicity, for example, if condition(k) is True then condition(k + 1) is True, then we can consider binary search.\n1011. Capacity To Ship Packages Within D Days [Medium] A conveyor belt has packages that must be shipped from one port to another within D days. The i-th package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.\nExample :\n1 2 3 4 5 6 7 8 9 10 11 Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5 Output: 15 Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this: 1st day: 1, 2, 3, 4, 5 2nd day: 6, 7 3rd day: 8 4th day: 9 5th day: 10 Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. Binary search probably would not come to our mind when we first meet this problem. We might automatically treat weights as search space and then realize we’ve entered a dead end after wasting lots of time. In fact, we are looking for the minimal one among all feasible capacities. We dig out the monotonicity of this problem: if we can successfully ship all packages within D days with capacity m, then we can definitely ship them all with any capacity larger than m. Now we can design a condition function, let’s call it feasible, given an input capacity, it returns whether it’s possible to ship all packages within D days. This can run in a greedy way: if there’s still room for the current package, we put this package onto the conveyor belt, otherwise we wait for the next day to place this package. If the total days needed exceeds D, we return False, otherwise we return True.\nNext, we need to initialize our boundary correctly. Obviously capacity should be at least max(weights), otherwise the conveyor belt couldn’t ship the heaviest package. On the other hand, capacity need not be more thansum(weights), because then we can ship all packages in just one day.\nNow we’ve got all we need to apply our binary search template:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def shipWithinDays(weights: List[int], D: int) -\u003e int: def feasible(capacity) -\u003e bool: days = 1 total = 0 for weight in weights: total += weight if total \u003e capacity: # too heavy, wait for the next day total = weight days += 1 if days \u003e D: # cannot ship within D days return False return True left, right = max(weights), sum(weights) while left \u003c right: mid = left + (right - left) // 2 if feasible(mid): right = mid else: left = mid + 1 return left 410. Split Array Largest Sum [Hard] Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.\nExample:\n1 2 3 4 5 6 7 8 9 Input: nums = [7,2,5,10,8] m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18. If you take a close look, you would probably see how similar this problem is with LC 1011 above. Similarly, we can design a feasible function: given an input threshold, then decide if we can split the array into several subarrays such that every subarray-sum is less than or equal to threshold. In this way, we discover the monotonicity of the problem: if feasible(m) is True, then all inputs larger than m can satisfy feasible function. You can see that the solution code is exactly the same as LC 1011.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def splitArray(nums: List[int], m: int) -\u003e int: def feasible(threshold) -\u003e bool: count = 1 total = 0 for num in nums: total += num if total \u003e threshold: total = num count += 1 if count \u003e m: return False return True left, right = max(nums), sum(nums) while left \u003c right: mid = left + (right - left) // 2 if feasible(mid): right = mid else: left = mid + 1 return left But we probably would have doubts: It’s true that left returned by our solution is the minimal value satisfying feasible, but how can we know that we can split the original array to actually get this subarray-sum? For example, let’s say nums = [7,2,5,10,8] and m = 2. We have 4 different ways to split the array to get 4 different largest subarray-sum correspondingly: 25:[[7], [2,5,10,8]], 23:[[7,2], [5,10,8]], 18:[[7,2,5], [10,8]], 24:[[7,2,5,10], [8]]. Only 4 values. But our search space [max(nums), sum(nums)] = [10, 32] has much more that just 4 values. That is, no matter how we split the input array, we cannot get most of the values in our search space.\nLet’s say k is the minimal value satisfying feasible function. We can prove the correctness of our solution with proof by contradiction. Assume that no subarray’s sum is equal to k, that is, every subarray sum is less than k. The variable total inside feasible function keeps track of the total weights of current load. If our assumption is correct, then total would always be less than k. As a result, feasible(k - 1) must be True, because total would at most be equal to k - 1 and would never trigger the if-clause if total \u003e threshold, therefore feasible(k - 1) must have the same output as feasible(k), which is True. But we already know that k is the minimal value satisfying feasible function, so feasible(k - 1) has to be False, which is a contradiction. So our assumption is incorrect. Now we’ve proved that our algorithm is correct.\n875. Koko Eating Bananas [Medium] Koko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them instead, and won’t eat any more bananas during this hour.\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. Return the minimum integer K such that she can eat all the bananas within H hours.\nExample :\n1 2 Input: piles = [3,6,7,11], H = 8 Output: 4 1 2 Input: piles = [30,11,23,4,20], H = 5 Output: 30 1 2 Input: piles = [30,11,23,4,20], H = 6 Output: 23 Very similar to LC 1011 and LC 410 mentioned above. Let’s design a feasible function, given an input speed, determine whether Koko can finish all bananas within H hours with hourly eating speed speed. Obviously, the lower bound of the search space is 1, and upper bound is max(piles), because Koko can only choose one pile of bananas to eat every hour.\n1 2 3 4 5 6 7 8 9 10 11 12 13 def minEatingSpeed(piles: List[int], H: int) -\u003e int: def feasible(speed) -\u003e bool: # return sum(math.ceil(pile / speed) for pile in piles) \u003c= H # slower return sum((pile - 1) // speed + 1 for pile in piles) \u003c= H # faster left, right = 1, max(piles) while left \u003c right: mid = left + (right - left) // 2 if feasible(mid): right = mid else: left = mid + 1 return left 1482. Minimum Number of Days to Make m Bouquets [Medium] Given an integer array bloomDay, an integer m and an integer k. We need to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden. The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet. Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.\nExamples:\n1 2 3 4 5 6 7 Input: bloomDay = [1,10,3,10,2], m = 3, k = 1 Output: 3 Explanation: Let's see what happened in the first three days. x means flower bloomed and _ means flower didn't bloom in the garden. We need 3 bouquets each should contain 1 flower. After day 1: [x, _, _, _, _] // we can only make one bouquet. After day 2: [x, _, _, _, x] // we can only make two bouquets. After day 3: [x, _, x, _, x] // we can make 3 bouquets. The answer is 3. 1 2 3 Input: bloomDay = [1,10,3,10,2], m = 3, k = 2 Output: -1 Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1. Now that we’ve solved three advanced problems above, this one should be pretty easy to do. The monotonicity of this problem is very clear: if we can make m bouquets after waiting for d days, then we can definitely finish that as well if we wait for more than d days.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def minDays(bloomDay: List[int], m: int, k: int) -\u003e int: def feasible(days) -\u003e bool: bonquets, flowers = 0, 0 for bloom in bloomDay: if bloom \u003e days: flowers = 0 else: bonquets += (flowers + 1) // k flowers = (flowers + 1) % k return bonquets \u003e= m if len(bloomDay) \u003c m * k: return -1 left, right = 1, max(bloomDay) while left \u003c right: mid = left + (right - left) // 2 if feasible(mid): right = mid else: left = mid + 1 return left 668. Kth Smallest Number in Multiplication Table [Hard] Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table? Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.\nExample :\n1 2 3 4 5 6 7 8 9 Input: m = 3, n = 3, k = 5 Output: 3 Explanation: The Multiplication Table: 1\t2\t3 2\t4\t6 3\t6\t9 The 5-th smallest number is 3 (1, 2, 2, 3, 3). For Kth-Smallest problems like this, what comes to our mind first is Heap. Usually we can maintain a Min-Heap and just pop the top of the Heap for k times. However, that doesn’t work out in this problem. We don’t have every single number in the entire Multiplication Table, instead, we only have the height and the length of the table. If we are to apply Heap method, we need to explicitly calculate these m * n values and save them to a heap. The time complexity and space complexity of this process are both O(mn), which is quite inefficient. This is when binary search comes in. Remember we say that designing condition function is the most difficult part? In order to find the k-th smallest value in the table, we can design an enough function, given an input num, determine whether there’re at least k values less than or equal to num. The minimal num satisfying enough function is the answer we’re looking for. Recall that the key to binary search is discovering monotonicity. In this problem, if num satisfies enough, then of course any value larger than num can satisfy. This monotonicity is the fundament of our binary search algorithm.\nLet’s consider search space. Obviously the lower bound should be 1, and the upper bound should be the largest value in the Multiplication Table, which is m * n, then we have search space [1, m * n]. The overwhelming advantage of binary search solution to heap solution is that it doesn’t need to explicitly calculate all numbers in that table, all it needs is just picking up one value out of the search space and apply enough function to this value, to determine should we keep the left half or the right half of the search space. In this way, binary search solution only requires constant space complexity, much better than heap solution.\nNext let’s consider how to implement enough function. It can be observed that every row in the Multiplication Table is just multiples of its index. For example, all numbers in 3rd row [3,6,9,12,15...] are multiples of 3. Therefore, we can just go row by row to count the total number of entries less than or equal to input num. Following is the complete solution.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def findKthNumber(m: int, n: int, k: int) -\u003e int: def enough(num) -\u003e bool: count = 0 for val in range(1, m + 1): # count row by row add = min(num // val, n) if add == 0: # early exit break count += add return count \u003e= k left, right = 1, n * m while left \u003c right: mid = left + (right - left) // 2 if enough(mid): right = mid else: left = mid + 1 return left In LC 410 above, we have doubt “Is the result from binary search actually a subarray sum?”. Here we have a similar doubt: “Is the result from binary search actually in the Multiplication Table?”. The answer is yes, and we also can apply proof by contradiction. Denote num as the minimal input that satisfies enough function. Let’s assume that num is not in the table, which means that num is not divisible by any val in [1, m], that is, num % val \u003e 0. Therefore, changing the input from num to num - 1 doesn’t have any effect on the expression add = min(num // val, n). So enough(num - 1) would also return True, same as enough(num). But we already know num is the minimal input satisfying enough function, so enough(num - 1) has to be False. Contradiction! The opposite of our original assumption is true: num is actually in the table.\n719. Find K-th Smallest Pair Distance [Hard] Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.\nExample :\n1 2 3 4 5 6 7 8 9 Input: nums = [1,3,1] k = 1 Output: 0 Explanation: Following are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0. (1,3) -\u003e 2 (1,1) -\u003e 0 (3,1) -\u003e 2 Very similar to LC 668 above, both are about finding Kth-Smallest. Just like LC 668, We can design an enough function, given an input distance, determine whether there’re at least k pairs whose distances are less than or equal to distance. We can sort the input array and use two pointers (fast pointer and slow pointer, pointed at a pair) to scan it. Both pointers go from leftmost end. If the current pair pointed at has a distance less than or equal to distance, all pairs between these pointers are valid (since the array is already sorted), we move forward the fast pointer. Otherwise, we move forward the slow pointer. By the time both pointers reach the rightmost end, we finish our scan and see if total counts exceed k. Here is the implementation:\n1 2 3 4 5 6 7 8 def enough(distance) -\u003e bool: # two pointers count, i, j = 0, 0, 0 while i \u003c n or j \u003c n: while j \u003c n and nums[j] - nums[i] \u003c= distance: # move fast pointer j += 1 count += j - i - 1 # count pairs i += 1 # move slow pointer return count \u003e= k Obviously, our search space should be [0, max(nums) - min(nums)]. Now we are ready to copy-paste our template:\n1 2 3 4 5 6 7 8 9 10 11 def smallestDistancePair(nums: List[int], k: int) -\u003e int: nums.sort() n = len(nums) left, right = 0, nums[-1] - nums[0] while left \u003c right: mid = left + (right - left) // 2 if enough(mid): right = mid else: left = mid + 1 return left 1201. Ugly Number III [Medium] Write a program to find the n-th ugly number. Ugly numbers are positive integers which are divisible by a or b or c.\nExample :\n1 2 3 Input: n = 3, a = 2, b = 3, c = 5 Output: 4 Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4. 1 2 3 Input: n = 4, a = 2, b = 3, c = 4 Output: 6 Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6. Nothing special. Still finding the Kth-Smallest. We need to design an enough function, given an input num, determine whether there are at least n ugly numbers less than or equal to num. Since a might be a multiple of b or c, or the other way round, we need the help of greatest common divisor to avoid counting duplicate numbers.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def nthUglyNumber(n: int, a: int, b: int, c: int) -\u003e int: def enough(num) -\u003e bool: total = num//a + num//b + num//c - num//ab - num//ac - num//bc + num//abc return total \u003e= n ab = a * b // math.gcd(a, b) ac = a * c // math.gcd(a, c) bc = b * c // math.gcd(b, c) abc = a * bc // math.gcd(a, bc) left, right = 1, 10 ** 10 while left \u003c right: mid = left + (right - left) // 2 if enough(mid): right = mid else: left = mid + 1 return left 1283. Find the Smallest Divisor Given a Threshold [Medium] Given an array of integers nums and an integer threshold, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.\nEach result of division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5). It is guaranteed that there will be an answer.\nExample :\n1 2 3 4 Input: nums = [1,2,5,9], threshold = 6 Output: 5 Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. If the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). After so many problems introduced above, this one should be a piece of cake. We don’t even need to bother to design a condition function, because the problem has already told us explicitly what condition we need to satisfy.\n1 2 3 4 5 6 7 8 9 10 11 12 def smallestDivisor(nums: List[int], threshold: int) -\u003e int: def condition(divisor) -\u003e bool: return sum((num - 1) // divisor + 1 for num in nums) \u003c= threshold left, right = 1, max(nums) while left \u003c right: mid = left + (right - left) // 2 if condition(mid): right = mid else: left = mid + 1 return left End Wow, thank you so much for making it to the end! Really appreciate that. As you can see from the python codes above, they all look very similar to each other. That’s because I copy-pasted my own template all the time. No exception. This is the strong proof of my template’s powerfulness and adaptability. I believe everyone can acquire this binary search template to solve many problems. All we need is just more practice to build up our ability to discover the monotonicity of the problem and to design a beautiful condition function.\nHope this helps.\nReference\n[C++ / Fast / Very clear explanation / Clean Code] Solution with Greedy Algorithm and Binary Search Approach the problem using the “trial and error” algorithm Binary Search 101 The-Ultimate-Binary-Search-Handbook - LeetCode ugly-number-iii Binary Search with picture \u0026 Binary Search Template - LeetCode ","wordCount":"4800","inLanguage":"en","image":"https://res.cloudinary.com/samirpaul/image/upload/w_1100,c_fit,co_rgb:FFFFFF,l_text:Arial_75_bold:Binary Search Template/og-image.webp","datePublished":"2021-01-20T00:00:00Z","dateModified":"2021-01-20T00:00:00Z","author":[{"@type":"Person","name":"Samir Paul"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://samirpaulb.github.io/posts/binary-search-template/"},"publisher":{"@type":"Organization","name":"Samir Paul","logo":{"@type":"ImageObject","url":"https://samirpaulb.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://samirpaulb.github.io/ accesskey=h title="Samir Paul (Alt + H)">Samir Paul</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://samirpaulb.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://samirpaulb.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://samirpaulb.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://samirpaulb.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://samirpaulb.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Binary Search Template</h1><div class=post-meta><span title='2021-01-20 00:00:00 +0000 UTC'>January 20, 2021</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;4800 words&nbsp;·&nbsp;Samir Paul</div></header><figure class=entry-cover><img loading=eager src=https://res.cloudinary.com/samirpaul/image/upload/w_1100,c_fit,co_rgb:FFFFFF,l_text:Arial_75_bold:Binary%20Search%20Template/og-image.webp alt="Binary Search Template"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#-most-generalized-binary-search aria-label=">> Most Generalized Binary Search">>> Most Generalized Binary Search</a></li><li><a href=#-basic-application aria-label=">> Basic Application">>> Basic Application</a><ul><li><a href=#278-first-bad-version-easyhttpsleetcodecomproblemsfirst-bad-version aria-label="278. First Bad Version [Easy]">278. First Bad Version [Easy]</a></li><li><a href=#69-sqrtx-easyhttpsleetcodecomproblemssqrtx aria-label="69. Sqrt(x) [Easy]">69. Sqrt(x) [Easy]</a></li><li><a href=#35-search-insert-position-easyhttpsleetcodecomproblemssearch-insert-position aria-label="35. Search Insert Position [Easy]">35. Search Insert Position [Easy]</a></li></ul></li><li><a href=#-advanced-application aria-label=">> Advanced Application">>> Advanced Application</a><ul><li><a href=#1011-capacity-to-ship-packages-within-d-days-mediumhttpsleetcodecomproblemscapacity-to-ship-packages-within-d-days aria-label="1011. Capacity To Ship Packages Within D Days [Medium]">1011. Capacity To Ship Packages Within D Days [Medium]</a></li><li><a href=#410-split-array-largest-sum-hardhttpsleetcodecomproblemssplit-array-largest-sum aria-label="410. Split Array Largest Sum [Hard]">410. Split Array Largest Sum [Hard]</a></li><li><a href=#875-koko-eating-bananas-mediumhttpsleetcodecomproblemskoko-eating-bananas aria-label="875. Koko Eating Bananas [Medium]">875. Koko Eating Bananas [Medium]</a></li><li><a href=#1482-minimum-number-of-days-to-make-m-bouquets-mediumhttpsleetcodecomproblemsminimum-number-of-days-to-make-m-bouquets aria-label="1482. Minimum Number of Days to Make m Bouquets [Medium]">1482. Minimum Number of Days to Make m Bouquets [Medium]</a></li><li><a href=#668-kth-smallest-number-in-multiplication-table-hardhttpsleetcodecomproblemskth-smallest-number-in-multiplication-tabledescription aria-label="668. Kth Smallest Number in Multiplication Table [Hard]">668. Kth Smallest Number in Multiplication Table [Hard]</a></li><li><a href=#719-find-k-th-smallest-pair-distance-hardhttpsleetcodecomproblemsfind-k-th-smallest-pair-distance aria-label="719. Find K-th Smallest Pair Distance [Hard]">719. Find K-th Smallest Pair Distance [Hard]</a></li><li><a href=#1201-ugly-number-iii-mediumhttpsleetcodecomproblemsugly-number-iii aria-label="1201. Ugly Number III [Medium]">1201. Ugly Number III [Medium]</a></li><li><a href=#1283-find-the-smallest-divisor-given-a-threshold-mediumhttpsleetcodecomproblemsfind-the-smallest-divisor-given-a-threshold aria-label="1283. Find the Smallest Divisor Given a Threshold [Medium]">1283. Find the Smallest Divisor Given a Threshold [Medium]</a></li></ul></li><li><a href=#end aria-label=End>End</a></li></ul></div></details></div><div class=post-content><p>Binary Search is quite easy to understand conceptually. Basically, it splits the search space into two halves and only keep the half that probably has the search target and throw away the other half that would not possibly have the answer. In this manner, we reduce the search space to half the size at every step, until we find the target. Binary Search helps us reduce the search time from linear O(n) to logarithmic O(log n). <strong>But when it comes to implementation, it&rsquo;s rather difficult to write a bug-free code in just a few minutes</strong>. Some of the most common problems include:</p><ul><li>When to exit the loop? Should we use <code>left &lt; right</code> or <code>left &lt;= right</code> as the while loop condition?</li><li>How to initialize the boundary variable <code>left</code> and <code>right</code>?</li><li>How to update the boundary? How to choose the appropriate combination from <code>left = mid</code>, <code>left = mid + 1</code> and <code>right = mid</code>, <code>right = mid - 1</code>?</li></ul><p>A rather common misunderstanding of binary search is that people often think this technique could only be used in simple scenario like &ldquo;Given a sorted array, find a specific value in it&rdquo;. As a matter of fact, it can be applied to much more complicated situations.</p><p>After a lot of practice in LeetCode, I&rsquo;ve made a powerful binary search template and solved many Hard problems by just slightly twisting this template. I&rsquo;ll share the template with you guys in this post. <strong>I don&rsquo;t want to just show off the code and leave. Most importantly, I want to share the logical thinking: how to apply this general template to all sorts of problems</strong>. Hopefully, after reading this post, people wouldn&rsquo;t be pissed off any more when LeetCoding, &ldquo;This problem could be solved with binary search! Why didn&rsquo;t I think of that before!&rdquo;</p><hr><h1 id=-most-generalized-binary-search>>> Most Generalized Binary Search<a hidden class=anchor aria-hidden=true href=#-most-generalized-binary-search>#</a></h1><p>Suppose we have a <strong>search space</strong>. It could be an array, a range, etc. Usually it&rsquo;s sorted in ascending order. For most tasks, we can transform the requirement into the following generalized form:</p><p><strong>Minimize k , s.t. condition(k) is True</strong></p><p>The following code is the most generalized binary search template:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def binary_search(array) -&gt; int:
</span></span><span class=line><span class=cl>    def condition(value) -&gt; bool:
</span></span><span class=line><span class=cl>        pass
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    left, right = min(search_space), max(search_space) # could be [0, n], [1, n] etc. Depends on problem
</span></span><span class=line><span class=cl>    while left &lt; right:
</span></span><span class=line><span class=cl>        mid = left + (right - left) // 2
</span></span><span class=line><span class=cl>        if condition(mid):
</span></span><span class=line><span class=cl>            right = mid
</span></span><span class=line><span class=cl>        else:
</span></span><span class=line><span class=cl>            left = mid + 1
</span></span><span class=line><span class=cl>    return left
</span></span></code></pre></td></tr></table></div></div><p>What&rsquo;s really nice of this template is that, for most of the binary search problems, <strong>we only need to modify three parts after copy-pasting this template, and never need to worry about corner cases and bugs in code any more</strong>:</p><ul><li>Correctly initialize the boundary variables <code>left</code> and <code>right</code> to specify search space. Only one rule: set up the boundary to <strong>include all possible elements</strong>;</li><li>Decide return value. Is it <code>return left</code> or <code>return left - 1</code>? Remember this: <strong>after exiting the while loop, <code>left</code> is the minimal k​ satisfying the <code>condition</code> function</strong>;</li><li>Design the <code>condition</code> function. This is the most difficult and most beautiful part. Needs lots of practice.</li></ul><p>Below I&rsquo;ll show you guys how to apply this powerful template to many LeetCode problems.</p><hr><h1 id=-basic-application>>> Basic Application<a hidden class=anchor aria-hidden=true href=#-basic-application>#</a></h1><h2 id=278-first-bad-version-easyhttpsleetcodecomproblemsfirst-bad-version><a href=https://leetcode.com/problems/first-bad-version/>278. First Bad Version [Easy]</a><a hidden class=anchor aria-hidden=true href=#278-first-bad-version-easyhttpsleetcodecomproblemsfirst-bad-version>#</a></h2><p>You are a product manager and currently leading a team to develop a new product. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad.</p><p><strong>Example:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Given n = 5, and version = 4 is the first bad version.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>call isBadVersion(3) -&gt; false
</span></span><span class=line><span class=cl>call isBadVersion(5) -&gt; true
</span></span><span class=line><span class=cl>call isBadVersion(4) -&gt; true
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Then 4 is the first bad version. 
</span></span></code></pre></td></tr></table></div></div><p>First, we initialize <code>left = 1</code> and <code>right = n</code> to include all possible values. Then we notice that we don&rsquo;t even need to design the <code>condition</code> function. It&rsquo;s already given by the <code>isBadVersion</code> API. Finding the first bad version is equivalent to finding the minimal k satisfying <code>isBadVersion(k) is True</code>. Our template can fit in very nicely:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution:
</span></span><span class=line><span class=cl>    def firstBadVersion(self, n) -&gt; int:
</span></span><span class=line><span class=cl>        left, right = 1, n
</span></span><span class=line><span class=cl>        while left &lt; right:
</span></span><span class=line><span class=cl>            mid = left + (right - left) // 2
</span></span><span class=line><span class=cl>            if isBadVersion(mid):
</span></span><span class=line><span class=cl>                right = mid
</span></span><span class=line><span class=cl>            else:
</span></span><span class=line><span class=cl>                left = mid + 1
</span></span><span class=line><span class=cl>        return left
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=69-sqrtx-easyhttpsleetcodecomproblemssqrtx><a href=https://leetcode.com/problems/sqrtx/>69. Sqrt(x) [Easy]</a><a hidden class=anchor aria-hidden=true href=#69-sqrtx-easyhttpsleetcodecomproblemssqrtx>#</a></h2><p>Implement <code>int sqrt(int x)</code>. Compute and return the square root of <em>x</em>, where <em>x</em> is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p><p><strong>Example:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: 4
</span></span><span class=line><span class=cl>Output: 2
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: 8
</span></span><span class=line><span class=cl>Output: 2
</span></span></code></pre></td></tr></table></div></div><p>Easy one. First we need to search for minimal k satisfying condition <code>k^2 > x</code>, then <code>k - 1</code> is the answer to the question. We can easily come up with the solution. Notice that I set <code>right = x + 1</code> instead of <code>right = x</code> to deal with special input cases like <code>x = 0</code> and <code>x = 1</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6>6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7>7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8>8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=n>def</span><span class=w> </span><span class=nf>mySqrt</span><span class=p>(</span><span class=n>x</span><span class=p>:</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=kt>int</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>left</span><span class=p>,</span><span class=w> </span><span class=k>right</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=k>left</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=k>right</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>mid</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>left</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=p>(</span><span class=k>right</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=k>left</span><span class=p>)</span><span class=w> </span><span class=o>//</span><span class=w> </span><span class=mi>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>mid</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>mid</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>x</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>right</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mid</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>else</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mid</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>left</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=w>  </span><span class=c1># `left` is the minimum k value, `k - 1` is the answer
</span></span></span></code></pre></td></tr></table></div></div><hr><h2 id=35-search-insert-position-easyhttpsleetcodecomproblemssearch-insert-position><a href=https://leetcode.com/problems/search-insert-position/>35. Search Insert Position [Easy]</a><a hidden class=anchor aria-hidden=true href=#35-search-insert-position-easyhttpsleetcodecomproblemssearch-insert-position>#</a></h2><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.</p><p><strong>Example:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: [1,3,5,6], 5
</span></span><span class=line><span class=cl>Output: 2
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: [1,3,5,6], 2
</span></span><span class=line><span class=cl>Output: 1
</span></span></code></pre></td></tr></table></div></div><p>Very classic application of binary search. We are looking for the minimal k value satisfying <code>nums[k] >= target</code>, and we can just copy-paste our template. Notice that our solution is correct regardless of whether the input array <code>nums</code> has duplicates. Also notice that the input <code>target</code> might be larger than all elements in <code>nums</code> and therefore needs to placed at the end of the array. That&rsquo;s why we should initialize <code>right = len(nums)</code> instead of <code>right = len(nums) - 1</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution:
</span></span><span class=line><span class=cl>    def searchInsert(self, nums: List[int], target: int) -&gt; int:
</span></span><span class=line><span class=cl>        left, right = 0, len(nums)
</span></span><span class=line><span class=cl>        while left &lt; right:
</span></span><span class=line><span class=cl>            mid = left + (right - left) // 2
</span></span><span class=line><span class=cl>            if nums[mid] &gt;= target:
</span></span><span class=line><span class=cl>                right = mid
</span></span><span class=line><span class=cl>            else:
</span></span><span class=line><span class=cl>                left = mid + 1
</span></span><span class=line><span class=cl>        return left
</span></span></code></pre></td></tr></table></div></div><hr><h1 id=-advanced-application>>> Advanced Application<a hidden class=anchor aria-hidden=true href=#-advanced-application>#</a></h1><p>The above problems are quite easy to solve, because they already give us the array to be searched. We&rsquo;d know that we should use binary search to solve them at first glance. However, <strong>more often are the situations where the search space and search target are not so readily available</strong>. Sometimes we won&rsquo;t even realize that the problem should be solved with binary search &ndash; we might just turn to dynamic programming or DFS and get stuck for a very long time.</p><p>As for the question &ldquo;When can we use binary search?&rdquo;, my answer is that, <strong>If we can discover some kind of monotonicity, for example, if <code>condition(k) is True</code> then <code>condition(k + 1) is True</code>, then we can consider binary search</strong>.</p><h2 id=1011-capacity-to-ship-packages-within-d-days-mediumhttpsleetcodecomproblemscapacity-to-ship-packages-within-d-days><a href=https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/>1011. Capacity To Ship Packages Within D Days [Medium]</a><a hidden class=anchor aria-hidden=true href=#1011-capacity-to-ship-packages-within-d-days-mediumhttpsleetcodecomproblemscapacity-to-ship-packages-within-d-days>#</a></h2><p>A conveyor belt has packages that must be shipped from one port to another within <code>D</code> days. The <code>i</code>-th package on the conveyor belt has a weight of <code>weights[i]</code>. Each day, we load the ship with packages on the conveyor belt (in the order given by <code>weights</code>). We may not load more weight than the maximum weight capacity of the ship.</p><p>Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within <code>D</code> days.</p><p><strong>Example :</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5
</span></span><span class=line><span class=cl>Output: 15
</span></span><span class=line><span class=cl>Explanation: 
</span></span><span class=line><span class=cl>A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:
</span></span><span class=line><span class=cl>1st day: 1, 2, 3, 4, 5
</span></span><span class=line><span class=cl>2nd day: 6, 7
</span></span><span class=line><span class=cl>3rd day: 8
</span></span><span class=line><span class=cl>4th day: 9
</span></span><span class=line><span class=cl>5th day: 10
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. 
</span></span></code></pre></td></tr></table></div></div><p>Binary search probably would not come to our mind when we first meet this problem. We might automatically treat <code>weights</code> as search space and then realize we&rsquo;ve entered a dead end after wasting lots of time. In fact, we are looking for the minimal one among all feasible capacities. We dig out the monotonicity of this problem: if we can successfully ship all packages within <code>D</code> days with capacity <code>m</code>, then we can definitely ship them all with any capacity larger than <code>m</code>. Now we can design a <code>condition</code> function, let&rsquo;s call it <code>feasible</code>, given an input <code>capacity</code>, it returns whether it&rsquo;s possible to ship all packages within <code>D</code> days. This can run in a greedy way: if there&rsquo;s still room for the current package, we put this package onto the conveyor belt, otherwise we wait for the next day to place this package. If the total days needed exceeds <code>D</code>, we return <code>False</code>, otherwise we return <code>True</code>.</p><p>Next, we need to initialize our boundary correctly. Obviously <code>capacity</code> should be at least <code>max(weights)</code>, otherwise the conveyor belt couldn&rsquo;t ship the heaviest package. On the other hand, <code>capacity</code> need not be more than<code>sum(weights)</code>, because then we can ship all packages in just one day.</p><p>Now we&rsquo;ve got all we need to apply our binary search template:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span><span class=lnt id=hl-10-17><a class=lnlinks href=#hl-10-17>17</a>
</span><span class=lnt id=hl-10-18><a class=lnlinks href=#hl-10-18>18</a>
</span><span class=lnt id=hl-10-19><a class=lnlinks href=#hl-10-19>19</a>
</span><span class=lnt id=hl-10-20><a class=lnlinks href=#hl-10-20>20</a>
</span><span class=lnt id=hl-10-21><a class=lnlinks href=#hl-10-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def shipWithinDays(weights: List[int], D: int) -&gt; int:
</span></span><span class=line><span class=cl>    def feasible(capacity) -&gt; bool:
</span></span><span class=line><span class=cl>        days = 1
</span></span><span class=line><span class=cl>        total = 0
</span></span><span class=line><span class=cl>        for weight in weights:
</span></span><span class=line><span class=cl>            total += weight
</span></span><span class=line><span class=cl>            if total &gt; capacity:  # too heavy, wait for the next day
</span></span><span class=line><span class=cl>                total = weight
</span></span><span class=line><span class=cl>                days += 1
</span></span><span class=line><span class=cl>                if days &gt; D:  # cannot ship within D days
</span></span><span class=line><span class=cl>                    return False
</span></span><span class=line><span class=cl>        return True
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    left, right = max(weights), sum(weights)
</span></span><span class=line><span class=cl>    while left &lt; right:
</span></span><span class=line><span class=cl>        mid = left + (right - left) // 2
</span></span><span class=line><span class=cl>        if feasible(mid):
</span></span><span class=line><span class=cl>            right = mid
</span></span><span class=line><span class=cl>        else:
</span></span><span class=line><span class=cl>            left = mid + 1
</span></span><span class=line><span class=cl>    return left
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=410-split-array-largest-sum-hardhttpsleetcodecomproblemssplit-array-largest-sum><a href=https://leetcode.com/problems/split-array-largest-sum/>410. Split Array Largest Sum [Hard]</a><a hidden class=anchor aria-hidden=true href=#410-split-array-largest-sum-hardhttpsleetcodecomproblemssplit-array-largest-sum>#</a></h2><p>Given an array which consists of non-negative integers and an integer <em>m</em>, you can split the array into <em>m</em> non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these <em>m</em> subarrays.</p><p><strong>Example:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5>5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6>6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7>7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8>8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input:
</span></span><span class=line><span class=cl>nums = [7,2,5,10,8]
</span></span><span class=line><span class=cl>m = 2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Output:
</span></span><span class=line><span class=cl>18
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Explanation:
</span></span><span class=line><span class=cl>There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.
</span></span></code></pre></td></tr></table></div></div><p>If you take a close look, you would probably see how similar this problem is with LC 1011 above. Similarly, we can design a <code>feasible</code> function: given an input <code>threshold</code>, then decide if we can split the array into several subarrays such that every subarray-sum is less than or equal to <code>threshold</code>. In this way, we discover the monotonicity of the problem: if <code>feasible(m)</code> is <code>True</code>, then all inputs larger than <code>m</code> can satisfy <code>feasible</code> function. You can see that the solution code is exactly the same as LC 1011.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span><span class=lnt id=hl-12-17><a class=lnlinks href=#hl-12-17>17</a>
</span><span class=lnt id=hl-12-18><a class=lnlinks href=#hl-12-18>18</a>
</span><span class=lnt id=hl-12-19><a class=lnlinks href=#hl-12-19>19</a>
</span><span class=lnt id=hl-12-20><a class=lnlinks href=#hl-12-20>20</a>
</span><span class=lnt id=hl-12-21><a class=lnlinks href=#hl-12-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def splitArray(nums: List[int], m: int) -&gt; int:        
</span></span><span class=line><span class=cl>    def feasible(threshold) -&gt; bool:
</span></span><span class=line><span class=cl>        count = 1
</span></span><span class=line><span class=cl>        total = 0
</span></span><span class=line><span class=cl>        for num in nums:
</span></span><span class=line><span class=cl>            total += num
</span></span><span class=line><span class=cl>            if total &gt; threshold:
</span></span><span class=line><span class=cl>                total = num
</span></span><span class=line><span class=cl>                count += 1
</span></span><span class=line><span class=cl>                if count &gt; m:
</span></span><span class=line><span class=cl>                    return False
</span></span><span class=line><span class=cl>        return True
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    left, right = max(nums), sum(nums)
</span></span><span class=line><span class=cl>    while left &lt; right:
</span></span><span class=line><span class=cl>        mid = left + (right - left) // 2
</span></span><span class=line><span class=cl>        if feasible(mid):
</span></span><span class=line><span class=cl>            right = mid     
</span></span><span class=line><span class=cl>        else:
</span></span><span class=line><span class=cl>            left = mid + 1
</span></span><span class=line><span class=cl>    return left
</span></span></code></pre></td></tr></table></div></div><p>But we probably would have doubts: It&rsquo;s true that <code>left</code> returned by our solution is the minimal value satisfying <code>feasible</code>, but how can we know that we can split the original array to <strong>actually get this subarray-sum</strong>? For example, let&rsquo;s say <code>nums = [7,2,5,10,8]</code> and <code>m = 2</code>. We have 4 different ways to split the array to get 4 different largest subarray-sum correspondingly: <code>25:[[7], [2,5,10,8]]</code>, <code>23:[[7,2], [5,10,8]]</code>, <code>18:[[7,2,5], [10,8]]</code>, <code>24:[[7,2,5,10], [8]]</code>. Only 4 values. But our search space <code>[max(nums), sum(nums)] = [10, 32]</code> has much more that just 4 values. That is, no matter how we split the input array, we cannot get most of the values in our search space.</p><p>Let&rsquo;s say <code>k</code> is the minimal value satisfying <code>feasible</code> function. We can prove the correctness of our solution with <strong>proof by contradiction</strong>. Assume that no subarray&rsquo;s sum is equal to <code>k</code>, that is, every subarray sum is less than <code>k</code>. The variable <code>total</code> inside <code>feasible</code> function keeps track of the total weights of current load. If our assumption is correct, then <code>total</code> would always be less than <code>k</code>. As a result, <code>feasible(k - 1)</code> must be <code>True</code>, because <code>total</code> would at most be equal to <code>k - 1</code> and would never trigger the if-clause <code>if total > threshold</code>, <strong>therefore <code>feasible(k - 1)</code> must have the same output as <code>feasible(k)</code>, which is <code>True</code></strong>. But we already know that <code>k</code> is the minimal value satisfying <code>feasible</code> function, <strong>so <code>feasible(k - 1)</code> has to be <code>False</code>, which is a contradiction</strong>. So our assumption is incorrect. Now we&rsquo;ve proved that our algorithm is correct.</p><hr><h2 id=875-koko-eating-bananas-mediumhttpsleetcodecomproblemskoko-eating-bananas><a href=https://leetcode.com/problems/koko-eating-bananas/>875. Koko Eating Bananas [Medium]</a><a hidden class=anchor aria-hidden=true href=#875-koko-eating-bananas-mediumhttpsleetcodecomproblemskoko-eating-bananas>#</a></h2><p>Koko loves to eat bananas. There are <code>N</code> piles of bananas, the <code>i</code>-th pile has <code>piles[i]</code> bananas. The guards have gone and will come back in <code>H</code> hours. Koko can decide her bananas-per-hour eating speed of <code>K</code>. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than <code>K</code> bananas, she eats all of them instead, and won&rsquo;t eat any more bananas during this hour.</p><p>Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. <strong>Return the minimum integer <code>K</code> such that she can eat all the bananas within <code>H</code> hours</strong>.</p><p><strong>Example :</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: piles = [3,6,7,11], H = 8
</span></span><span class=line><span class=cl>Output: 4
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: piles = [30,11,23,4,20], H = 5
</span></span><span class=line><span class=cl>Output: 30
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: piles = [30,11,23,4,20], H = 6
</span></span><span class=line><span class=cl>Output: 23
</span></span></code></pre></td></tr></table></div></div><p>Very similar to LC 1011 and LC 410 mentioned above. Let&rsquo;s design a <code>feasible</code> function, given an input <code>speed</code>, determine whether Koko can finish all bananas within <code>H</code> hours with hourly eating speed <code>speed</code>. Obviously, the lower bound of the search space is 1, and upper bound is <code>max(piles)</code>, because Koko can only choose one pile of bananas to eat every hour.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span><span class=lnt id=hl-16-12><a class=lnlinks href=#hl-16-12>12</a>
</span><span class=lnt id=hl-16-13><a class=lnlinks href=#hl-16-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def minEatingSpeed(piles: List[int], H: int) -&gt; int:
</span></span><span class=line><span class=cl>    def feasible(speed) -&gt; bool:
</span></span><span class=line><span class=cl>        # return sum(math.ceil(pile / speed) for pile in piles) &lt;= H  # slower        
</span></span><span class=line><span class=cl>        return sum((pile - 1) // speed + 1 for pile in piles) &lt;= H  # faster
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    left, right = 1, max(piles)
</span></span><span class=line><span class=cl>    while left &lt; right:
</span></span><span class=line><span class=cl>        mid = left  + (right - left) // 2
</span></span><span class=line><span class=cl>        if feasible(mid):
</span></span><span class=line><span class=cl>            right = mid
</span></span><span class=line><span class=cl>        else:
</span></span><span class=line><span class=cl>            left = mid + 1
</span></span><span class=line><span class=cl>    return left
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=1482-minimum-number-of-days-to-make-m-bouquets-mediumhttpsleetcodecomproblemsminimum-number-of-days-to-make-m-bouquets><a href=https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/>1482. Minimum Number of Days to Make m Bouquets [Medium]</a><a hidden class=anchor aria-hidden=true href=#1482-minimum-number-of-days-to-make-m-bouquets-mediumhttpsleetcodecomproblemsminimum-number-of-days-to-make-m-bouquets>#</a></h2><p>Given an integer array <code>bloomDay</code>, an integer <code>m</code> and an integer <code>k</code>. We need to make <code>m</code> bouquets. To make a bouquet, you need to use <code>k</code> <strong>adjacent flowers</strong> from the garden. The garden consists of <code>n</code> flowers, the <code>ith</code> flower will bloom in the <code>bloomDay[i]</code> and then can be used in <strong>exactly one</strong> bouquet. Return <em>the minimum number of days</em> you need to wait to be able to make <code>m</code> bouquets from the garden. If it is impossible to make <code>m</code> bouquets return <strong>-1</strong>.</p><p><strong>Examples:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2>2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3>3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4>4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5>5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6>6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: bloomDay = [1,10,3,10,2], m = 3, k = 1
</span></span><span class=line><span class=cl>Output: 3
</span></span><span class=line><span class=cl>Explanation: Let&#39;s see what happened in the first three days. x means flower bloomed and _ means flower didn&#39;t bloom in the garden.
</span></span><span class=line><span class=cl>We need 3 bouquets each should contain 1 flower.
</span></span><span class=line><span class=cl>After day 1: [x, _, _, _, _]   // we can only make one bouquet.
</span></span><span class=line><span class=cl>After day 2: [x, _, _, _, x]   // we can only make two bouquets.
</span></span><span class=line><span class=cl>After day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1>1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2>2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: bloomDay = [1,10,3,10,2], m = 3, k = 2
</span></span><span class=line><span class=cl>Output: -1
</span></span><span class=line><span class=cl>Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.
</span></span></code></pre></td></tr></table></div></div><p>Now that we&rsquo;ve solved three advanced problems above, this one should be pretty easy to do. The monotonicity of this problem is very clear: if we can make <code>m</code> bouquets after waiting for <code>d</code> days, then we can definitely finish that as well if we wait for more than <code>d</code> days.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1> 1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2> 2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3> 3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4> 4</a>
</span><span class=lnt id=hl-19-5><a class=lnlinks href=#hl-19-5> 5</a>
</span><span class=lnt id=hl-19-6><a class=lnlinks href=#hl-19-6> 6</a>
</span><span class=lnt id=hl-19-7><a class=lnlinks href=#hl-19-7> 7</a>
</span><span class=lnt id=hl-19-8><a class=lnlinks href=#hl-19-8> 8</a>
</span><span class=lnt id=hl-19-9><a class=lnlinks href=#hl-19-9> 9</a>
</span><span class=lnt id=hl-19-10><a class=lnlinks href=#hl-19-10>10</a>
</span><span class=lnt id=hl-19-11><a class=lnlinks href=#hl-19-11>11</a>
</span><span class=lnt id=hl-19-12><a class=lnlinks href=#hl-19-12>12</a>
</span><span class=lnt id=hl-19-13><a class=lnlinks href=#hl-19-13>13</a>
</span><span class=lnt id=hl-19-14><a class=lnlinks href=#hl-19-14>14</a>
</span><span class=lnt id=hl-19-15><a class=lnlinks href=#hl-19-15>15</a>
</span><span class=lnt id=hl-19-16><a class=lnlinks href=#hl-19-16>16</a>
</span><span class=lnt id=hl-19-17><a class=lnlinks href=#hl-19-17>17</a>
</span><span class=lnt id=hl-19-18><a class=lnlinks href=#hl-19-18>18</a>
</span><span class=lnt id=hl-19-19><a class=lnlinks href=#hl-19-19>19</a>
</span><span class=lnt id=hl-19-20><a class=lnlinks href=#hl-19-20>20</a>
</span><span class=lnt id=hl-19-21><a class=lnlinks href=#hl-19-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def minDays(bloomDay: List[int], m: int, k: int) -&gt; int:
</span></span><span class=line><span class=cl>    def feasible(days) -&gt; bool:
</span></span><span class=line><span class=cl>        bonquets, flowers = 0, 0
</span></span><span class=line><span class=cl>        for bloom in bloomDay:
</span></span><span class=line><span class=cl>            if bloom &gt; days:
</span></span><span class=line><span class=cl>                flowers = 0
</span></span><span class=line><span class=cl>            else:
</span></span><span class=line><span class=cl>                bonquets += (flowers + 1) // k
</span></span><span class=line><span class=cl>                flowers = (flowers + 1) % k
</span></span><span class=line><span class=cl>        return bonquets &gt;= m
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if len(bloomDay) &lt; m * k:
</span></span><span class=line><span class=cl>        return -1
</span></span><span class=line><span class=cl>    left, right = 1, max(bloomDay)
</span></span><span class=line><span class=cl>    while left &lt; right:
</span></span><span class=line><span class=cl>        mid = left + (right - left) // 2
</span></span><span class=line><span class=cl>        if feasible(mid):
</span></span><span class=line><span class=cl>            right = mid
</span></span><span class=line><span class=cl>        else:
</span></span><span class=line><span class=cl>            left = mid + 1
</span></span><span class=line><span class=cl>    return left
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=668-kth-smallest-number-in-multiplication-table-hardhttpsleetcodecomproblemskth-smallest-number-in-multiplication-tabledescription><a href=https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/>668. Kth Smallest Number in Multiplication Table [Hard]</a><a hidden class=anchor aria-hidden=true href=#668-kth-smallest-number-in-multiplication-table-hardhttpsleetcodecomproblemskth-smallest-number-in-multiplication-tabledescription>#</a></h2><p>Nearly every one have used the <a href=https://en.wikipedia.org/wiki/Multiplication_table>Multiplication Table</a>. But could you find out the <code>k-th</code> smallest number quickly from the multiplication table? Given the height <code>m</code> and the length <code>n</code> of a <code>m * n</code> Multiplication Table, and a positive integer <code>k</code>, you need to return the <code>k-th</code> smallest number in this table.</p><p><strong>Example :</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1>1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2>2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3>3</a>
</span><span class=lnt id=hl-20-4><a class=lnlinks href=#hl-20-4>4</a>
</span><span class=lnt id=hl-20-5><a class=lnlinks href=#hl-20-5>5</a>
</span><span class=lnt id=hl-20-6><a class=lnlinks href=#hl-20-6>6</a>
</span><span class=lnt id=hl-20-7><a class=lnlinks href=#hl-20-7>7</a>
</span><span class=lnt id=hl-20-8><a class=lnlinks href=#hl-20-8>8</a>
</span><span class=lnt id=hl-20-9><a class=lnlinks href=#hl-20-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: m = 3, n = 3, k = 5
</span></span><span class=line><span class=cl>Output: 3
</span></span><span class=line><span class=cl>Explanation: 
</span></span><span class=line><span class=cl>The Multiplication Table:
</span></span><span class=line><span class=cl>1	2	3
</span></span><span class=line><span class=cl>2	4	6
</span></span><span class=line><span class=cl>3	6	9
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>The 5-th smallest number is 3 (1, 2, 2, 3, 3).
</span></span></code></pre></td></tr></table></div></div><p>For Kth-Smallest problems like this, what comes to our mind first is Heap. Usually we can maintain a Min-Heap and just pop the top of the Heap for k times. However, that doesn&rsquo;t work out in this problem. We don&rsquo;t have every single number in the entire Multiplication Table, instead, we only have the height and the length of the table. If we are to apply Heap method, we need to explicitly calculate these <code>m * n</code> values and save them to a heap. The time complexity and space complexity of this process are both O(mn), which is quite inefficient. This is when binary search comes in. Remember we say that designing <code>condition</code> function is the most difficult part? In order to find the k-th smallest value in the table, we can design an <code>enough</code> function, given an input <code>num</code>, determine whether there&rsquo;re at least k values less than or equal to <code>num</code>. <strong>The minimal <code>num</code> satisfying <code>enough</code> function is the answer we&rsquo;re looking for</strong>. Recall that the key to binary search is discovering monotonicity. In this problem, if <code>num</code> satisfies <code>enough</code>, then of course any value larger than <code>num</code> can satisfy. This monotonicity is the fundament of our binary search algorithm.</p><p>Let&rsquo;s consider search space. Obviously the lower bound should be 1, and the upper bound should be the largest value in the Multiplication Table, which is <code>m * n</code>, then we have search space <code>[1, m * n]</code>. The overwhelming advantage of binary search solution to heap solution is that it doesn&rsquo;t need to explicitly calculate all numbers in that table, all it needs is just picking up one value out of the search space and apply <code>enough</code> function to this value, to determine should we keep the left half or the right half of the search space. In this way, binary search solution only requires constant space complexity, much better than heap solution.</p><p>Next let&rsquo;s consider how to implement <code>enough</code> function. It can be observed that every row in the Multiplication Table is just multiples of its index. For example, all numbers in 3rd row <code>[3,6,9,12,15...]</code> are multiples of 3. Therefore, we can just go row by row to count the total number of entries less than or equal to input <code>num</code>. Following is the complete solution.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1> 1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2> 2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3> 3</a>
</span><span class=lnt id=hl-21-4><a class=lnlinks href=#hl-21-4> 4</a>
</span><span class=lnt id=hl-21-5><a class=lnlinks href=#hl-21-5> 5</a>
</span><span class=lnt id=hl-21-6><a class=lnlinks href=#hl-21-6> 6</a>
</span><span class=lnt id=hl-21-7><a class=lnlinks href=#hl-21-7> 7</a>
</span><span class=lnt id=hl-21-8><a class=lnlinks href=#hl-21-8> 8</a>
</span><span class=lnt id=hl-21-9><a class=lnlinks href=#hl-21-9> 9</a>
</span><span class=lnt id=hl-21-10><a class=lnlinks href=#hl-21-10>10</a>
</span><span class=lnt id=hl-21-11><a class=lnlinks href=#hl-21-11>11</a>
</span><span class=lnt id=hl-21-12><a class=lnlinks href=#hl-21-12>12</a>
</span><span class=lnt id=hl-21-13><a class=lnlinks href=#hl-21-13>13</a>
</span><span class=lnt id=hl-21-14><a class=lnlinks href=#hl-21-14>14</a>
</span><span class=lnt id=hl-21-15><a class=lnlinks href=#hl-21-15>15</a>
</span><span class=lnt id=hl-21-16><a class=lnlinks href=#hl-21-16>16</a>
</span><span class=lnt id=hl-21-17><a class=lnlinks href=#hl-21-17>17</a>
</span><span class=lnt id=hl-21-18><a class=lnlinks href=#hl-21-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def findKthNumber(m: int, n: int, k: int) -&gt; int:
</span></span><span class=line><span class=cl>    def enough(num) -&gt; bool:
</span></span><span class=line><span class=cl>        count = 0
</span></span><span class=line><span class=cl>        for val in range(1, m + 1):  # count row by row
</span></span><span class=line><span class=cl>            add = min(num // val, n)
</span></span><span class=line><span class=cl>            if add == 0:  # early exit
</span></span><span class=line><span class=cl>                break
</span></span><span class=line><span class=cl>            count += add
</span></span><span class=line><span class=cl>        return count &gt;= k                
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    left, right = 1, n * m
</span></span><span class=line><span class=cl>    while left &lt; right:
</span></span><span class=line><span class=cl>        mid = left + (right - left) // 2
</span></span><span class=line><span class=cl>        if enough(mid):
</span></span><span class=line><span class=cl>            right = mid
</span></span><span class=line><span class=cl>        else:
</span></span><span class=line><span class=cl>            left = mid + 1
</span></span><span class=line><span class=cl>    return left 
</span></span></code></pre></td></tr></table></div></div><p>In LC 410 above, we have doubt &ldquo;Is the result from binary search actually a subarray sum?&rdquo;. Here we have a similar doubt: &ldquo;<strong>Is the result from binary search actually in the Multiplication Table?</strong>&rdquo;. The answer is yes, and we also can apply proof by contradiction. Denote <code>num</code> as the minimal input that satisfies <code>enough</code> function. Let&rsquo;s assume that <code>num</code> is not in the table, which means that <code>num</code> is not divisible by any <code>val</code> in <code>[1, m]</code>, that is, <code>num % val > 0</code>. Therefore, changing the input from <code>num</code> to <code>num - 1</code> doesn&rsquo;t have any effect on the expression <code>add = min(num // val, n)</code>. So <code>enough(num - 1)</code> would also return <code>True</code>, same as <code>enough(num)</code>. But we already know <code>num</code> is the minimal input satisfying <code>enough</code> function, so <code>enough(num - 1)</code> has to be <code>False</code>. Contradiction! The opposite of our original assumption is true: <code>num</code> is actually in the table.</p><hr><h2 id=719-find-k-th-smallest-pair-distance-hardhttpsleetcodecomproblemsfind-k-th-smallest-pair-distance><a href=https://leetcode.com/problems/find-k-th-smallest-pair-distance/>719. Find K-th Smallest Pair Distance [Hard]</a><a hidden class=anchor aria-hidden=true href=#719-find-k-th-smallest-pair-distance-hardhttpsleetcodecomproblemsfind-k-th-smallest-pair-distance>#</a></h2><p>Given an integer array, return the k-th smallest <strong>distance</strong> among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.</p><p><strong>Example :</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1>1</a>
</span><span class=lnt id=hl-22-2><a class=lnlinks href=#hl-22-2>2</a>
</span><span class=lnt id=hl-22-3><a class=lnlinks href=#hl-22-3>3</a>
</span><span class=lnt id=hl-22-4><a class=lnlinks href=#hl-22-4>4</a>
</span><span class=lnt id=hl-22-5><a class=lnlinks href=#hl-22-5>5</a>
</span><span class=lnt id=hl-22-6><a class=lnlinks href=#hl-22-6>6</a>
</span><span class=lnt id=hl-22-7><a class=lnlinks href=#hl-22-7>7</a>
</span><span class=lnt id=hl-22-8><a class=lnlinks href=#hl-22-8>8</a>
</span><span class=lnt id=hl-22-9><a class=lnlinks href=#hl-22-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input:
</span></span><span class=line><span class=cl>nums = [1,3,1]
</span></span><span class=line><span class=cl>k = 1
</span></span><span class=line><span class=cl>Output: 0 
</span></span><span class=line><span class=cl>Explanation:
</span></span><span class=line><span class=cl>Following are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0.
</span></span><span class=line><span class=cl>(1,3) -&gt; 2
</span></span><span class=line><span class=cl>(1,1) -&gt; 0
</span></span><span class=line><span class=cl>(3,1) -&gt; 2
</span></span></code></pre></td></tr></table></div></div><p>Very similar to LC 668 above, both are about finding Kth-Smallest. Just like LC 668, We can design an <code>enough</code> function, given an input <code>distance</code>, determine whether there&rsquo;re at least k pairs whose distances are less than or equal to <code>distance</code>. We can sort the input array and use two pointers (fast pointer and slow pointer, pointed at a pair) to scan it. Both pointers go from leftmost end. If the current pair pointed at has a distance less than or equal to <code>distance</code>, all pairs between these pointers are valid (since the array is already sorted), we move forward the fast pointer. Otherwise, we move forward the slow pointer. By the time both pointers reach the rightmost end, we finish our scan and see if total counts exceed k. Here is the implementation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1>1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2>2</a>
</span><span class=lnt id=hl-23-3><a class=lnlinks href=#hl-23-3>3</a>
</span><span class=lnt id=hl-23-4><a class=lnlinks href=#hl-23-4>4</a>
</span><span class=lnt id=hl-23-5><a class=lnlinks href=#hl-23-5>5</a>
</span><span class=lnt id=hl-23-6><a class=lnlinks href=#hl-23-6>6</a>
</span><span class=lnt id=hl-23-7><a class=lnlinks href=#hl-23-7>7</a>
</span><span class=lnt id=hl-23-8><a class=lnlinks href=#hl-23-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def enough(distance) -&gt; bool:  # two pointers
</span></span><span class=line><span class=cl>    count, i, j = 0, 0, 0
</span></span><span class=line><span class=cl>    while i &lt; n or j &lt; n:
</span></span><span class=line><span class=cl>        while j &lt; n and nums[j] - nums[i] &lt;= distance:  # move fast pointer
</span></span><span class=line><span class=cl>            j += 1
</span></span><span class=line><span class=cl>        count += j - i - 1  # count pairs
</span></span><span class=line><span class=cl>        i += 1  # move slow pointer
</span></span><span class=line><span class=cl>    return count &gt;= k
</span></span></code></pre></td></tr></table></div></div><p>Obviously, our search space should be <code>[0, max(nums) - min(nums)]</code>. Now we are ready to copy-paste our template:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1> 1</a>
</span><span class=lnt id=hl-24-2><a class=lnlinks href=#hl-24-2> 2</a>
</span><span class=lnt id=hl-24-3><a class=lnlinks href=#hl-24-3> 3</a>
</span><span class=lnt id=hl-24-4><a class=lnlinks href=#hl-24-4> 4</a>
</span><span class=lnt id=hl-24-5><a class=lnlinks href=#hl-24-5> 5</a>
</span><span class=lnt id=hl-24-6><a class=lnlinks href=#hl-24-6> 6</a>
</span><span class=lnt id=hl-24-7><a class=lnlinks href=#hl-24-7> 7</a>
</span><span class=lnt id=hl-24-8><a class=lnlinks href=#hl-24-8> 8</a>
</span><span class=lnt id=hl-24-9><a class=lnlinks href=#hl-24-9> 9</a>
</span><span class=lnt id=hl-24-10><a class=lnlinks href=#hl-24-10>10</a>
</span><span class=lnt id=hl-24-11><a class=lnlinks href=#hl-24-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def smallestDistancePair(nums: List[int], k: int) -&gt; int:
</span></span><span class=line><span class=cl>    nums.sort()
</span></span><span class=line><span class=cl>    n = len(nums)
</span></span><span class=line><span class=cl>    left, right = 0, nums[-1] - nums[0]
</span></span><span class=line><span class=cl>    while left &lt; right:
</span></span><span class=line><span class=cl>        mid = left + (right - left) // 2
</span></span><span class=line><span class=cl>        if enough(mid):
</span></span><span class=line><span class=cl>            right = mid
</span></span><span class=line><span class=cl>        else:
</span></span><span class=line><span class=cl>            left = mid + 1
</span></span><span class=line><span class=cl>    return left
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=1201-ugly-number-iii-mediumhttpsleetcodecomproblemsugly-number-iii><a href=https://leetcode.com/problems/ugly-number-iii/>1201. Ugly Number III [Medium]</a><a hidden class=anchor aria-hidden=true href=#1201-ugly-number-iii-mediumhttpsleetcodecomproblemsugly-number-iii>#</a></h2><p>Write a program to find the <code>n</code>-th ugly number. Ugly numbers are <strong>positive integers</strong> which are divisible by <code>a</code> <strong>or</strong> <code>b</code> <strong>or</strong> <code>c</code>.</p><p><strong>Example :</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-25-1><a class=lnlinks href=#hl-25-1>1</a>
</span><span class=lnt id=hl-25-2><a class=lnlinks href=#hl-25-2>2</a>
</span><span class=lnt id=hl-25-3><a class=lnlinks href=#hl-25-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: n = 3, a = 2, b = 3, c = 5
</span></span><span class=line><span class=cl>Output: 4
</span></span><span class=line><span class=cl>Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-26-1><a class=lnlinks href=#hl-26-1>1</a>
</span><span class=lnt id=hl-26-2><a class=lnlinks href=#hl-26-2>2</a>
</span><span class=lnt id=hl-26-3><a class=lnlinks href=#hl-26-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: n = 4, a = 2, b = 3, c = 4
</span></span><span class=line><span class=cl>Output: 6
</span></span><span class=line><span class=cl>Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.
</span></span></code></pre></td></tr></table></div></div><p>Nothing special. Still finding the Kth-Smallest. We need to design an <code>enough</code> function, given an input <code>num</code>, determine whether there are at least n ugly numbers less than or equal to <code>num</code>. Since <code>a</code> might be a multiple of <code>b</code> or <code>c</code>, or the other way round, we need the help of greatest common divisor to avoid counting duplicate numbers.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-27-1><a class=lnlinks href=#hl-27-1> 1</a>
</span><span class=lnt id=hl-27-2><a class=lnlinks href=#hl-27-2> 2</a>
</span><span class=lnt id=hl-27-3><a class=lnlinks href=#hl-27-3> 3</a>
</span><span class=lnt id=hl-27-4><a class=lnlinks href=#hl-27-4> 4</a>
</span><span class=lnt id=hl-27-5><a class=lnlinks href=#hl-27-5> 5</a>
</span><span class=lnt id=hl-27-6><a class=lnlinks href=#hl-27-6> 6</a>
</span><span class=lnt id=hl-27-7><a class=lnlinks href=#hl-27-7> 7</a>
</span><span class=lnt id=hl-27-8><a class=lnlinks href=#hl-27-8> 8</a>
</span><span class=lnt id=hl-27-9><a class=lnlinks href=#hl-27-9> 9</a>
</span><span class=lnt id=hl-27-10><a class=lnlinks href=#hl-27-10>10</a>
</span><span class=lnt id=hl-27-11><a class=lnlinks href=#hl-27-11>11</a>
</span><span class=lnt id=hl-27-12><a class=lnlinks href=#hl-27-12>12</a>
</span><span class=lnt id=hl-27-13><a class=lnlinks href=#hl-27-13>13</a>
</span><span class=lnt id=hl-27-14><a class=lnlinks href=#hl-27-14>14</a>
</span><span class=lnt id=hl-27-15><a class=lnlinks href=#hl-27-15>15</a>
</span><span class=lnt id=hl-27-16><a class=lnlinks href=#hl-27-16>16</a>
</span><span class=lnt id=hl-27-17><a class=lnlinks href=#hl-27-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def nthUglyNumber(n: int, a: int, b: int, c: int) -&gt; int:
</span></span><span class=line><span class=cl>    def enough(num) -&gt; bool:
</span></span><span class=line><span class=cl>        total = num//a + num//b + num//c - num//ab - num//ac - num//bc + num//abc
</span></span><span class=line><span class=cl>        return total &gt;= n
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    ab = a * b // math.gcd(a, b)
</span></span><span class=line><span class=cl>    ac = a * c // math.gcd(a, c)
</span></span><span class=line><span class=cl>    bc = b * c // math.gcd(b, c)
</span></span><span class=line><span class=cl>    abc = a * bc // math.gcd(a, bc)
</span></span><span class=line><span class=cl>    left, right = 1, 10 ** 10
</span></span><span class=line><span class=cl>    while left &lt; right:
</span></span><span class=line><span class=cl>        mid = left + (right - left) // 2
</span></span><span class=line><span class=cl>        if enough(mid):
</span></span><span class=line><span class=cl>            right = mid
</span></span><span class=line><span class=cl>        else:
</span></span><span class=line><span class=cl>            left = mid + 1
</span></span><span class=line><span class=cl>    return left
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=1283-find-the-smallest-divisor-given-a-threshold-mediumhttpsleetcodecomproblemsfind-the-smallest-divisor-given-a-threshold><a href=https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/>1283. Find the Smallest Divisor Given a Threshold [Medium]</a><a hidden class=anchor aria-hidden=true href=#1283-find-the-smallest-divisor-given-a-threshold-mediumhttpsleetcodecomproblemsfind-the-smallest-divisor-given-a-threshold>#</a></h2><p>Given an array of integers <code>nums</code> and an integer <code>threshold</code>, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the <strong>smallest</strong> divisor such that the result mentioned above is less than or equal to <code>threshold</code>.</p><p>Each result of division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5). It is guaranteed that there will be an answer.</p><p><strong>Example :</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-28-1><a class=lnlinks href=#hl-28-1>1</a>
</span><span class=lnt id=hl-28-2><a class=lnlinks href=#hl-28-2>2</a>
</span><span class=lnt id=hl-28-3><a class=lnlinks href=#hl-28-3>3</a>
</span><span class=lnt id=hl-28-4><a class=lnlinks href=#hl-28-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Input: nums = [1,2,5,9], threshold = 6
</span></span><span class=line><span class=cl>Output: 5
</span></span><span class=line><span class=cl>Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. 
</span></span><span class=line><span class=cl>If the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). 
</span></span></code></pre></td></tr></table></div></div><p>After so many problems introduced above, this one should be a piece of cake. We don&rsquo;t even need to bother to design a <code>condition</code> function, because the problem has already told us explicitly what condition we need to satisfy.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-29-1><a class=lnlinks href=#hl-29-1> 1</a>
</span><span class=lnt id=hl-29-2><a class=lnlinks href=#hl-29-2> 2</a>
</span><span class=lnt id=hl-29-3><a class=lnlinks href=#hl-29-3> 3</a>
</span><span class=lnt id=hl-29-4><a class=lnlinks href=#hl-29-4> 4</a>
</span><span class=lnt id=hl-29-5><a class=lnlinks href=#hl-29-5> 5</a>
</span><span class=lnt id=hl-29-6><a class=lnlinks href=#hl-29-6> 6</a>
</span><span class=lnt id=hl-29-7><a class=lnlinks href=#hl-29-7> 7</a>
</span><span class=lnt id=hl-29-8><a class=lnlinks href=#hl-29-8> 8</a>
</span><span class=lnt id=hl-29-9><a class=lnlinks href=#hl-29-9> 9</a>
</span><span class=lnt id=hl-29-10><a class=lnlinks href=#hl-29-10>10</a>
</span><span class=lnt id=hl-29-11><a class=lnlinks href=#hl-29-11>11</a>
</span><span class=lnt id=hl-29-12><a class=lnlinks href=#hl-29-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def smallestDivisor(nums: List[int], threshold: int) -&gt; int:
</span></span><span class=line><span class=cl>    def condition(divisor) -&gt; bool:
</span></span><span class=line><span class=cl>        return sum((num - 1) // divisor + 1 for num in nums) &lt;= threshold
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    left, right = 1, max(nums)
</span></span><span class=line><span class=cl>    while left &lt; right:
</span></span><span class=line><span class=cl>        mid = left + (right - left) // 2
</span></span><span class=line><span class=cl>        if condition(mid):
</span></span><span class=line><span class=cl>            right = mid
</span></span><span class=line><span class=cl>        else:
</span></span><span class=line><span class=cl>            left = mid + 1
</span></span><span class=line><span class=cl>    return left
</span></span></code></pre></td></tr></table></div></div><hr><h1 id=end>End<a hidden class=anchor aria-hidden=true href=#end>#</a></h1><p>Wow, thank you so much for making it to the end! Really appreciate that. As you can see from the python codes above, they all look very similar to each other. That&rsquo;s because I copy-pasted my own template all the time. No exception. This is the strong proof of my template&rsquo;s powerfulness and adaptability. I believe everyone can acquire this binary search template to solve many problems. All we need is just more practice to build up our ability to discover the monotonicity of the problem and to design a beautiful <code>condition</code> function.</p><p>Hope this helps.</p><p><strong>Reference</strong></p><ul><li><a href=https://leetcode.com/problems/split-array-largest-sum/discuss/89819/C%2B%2B-Fast-Very-clear-explanation-Clean-Code-Solution-with-Greedy-Algorithm-and-Binary-Search>[C++ / Fast / Very clear explanation / Clean Code] Solution with Greedy Algorithm and Binary Search</a></li><li><a href=https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/109082/Approach-the-problem-using-the-%22trial-and-error%22-algorithm>Approach the problem using the &ldquo;trial and error&rdquo; algorithm</a></li><li><a href=https://leetcode.com/problems/binary-search/discuss/423162/Binary-Search-101-The-Ultimate-Binary-Search-Handbook>Binary Search 101 The-Ultimate-Binary-Search-Handbook - LeetCode</a></li><li><a href=https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template>ugly-number-iii Binary Search with picture & Binary Search Template - LeetCode</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://samirpaulb.github.io/tags/computer-science/>computer-science</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Binary Search Template on x" href="https://x.com/intent/tweet/?text=Binary%20Search%20Template&amp;url=https%3a%2f%2fsamirpaulb.github.io%2fposts%2fbinary-search-template%2f&amp;hashtags=computer-science"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Binary Search Template on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsamirpaulb.github.io%2fposts%2fbinary-search-template%2f&amp;title=Binary%20Search%20Template&amp;summary=Binary%20Search%20Template&amp;source=https%3a%2f%2fsamirpaulb.github.io%2fposts%2fbinary-search-template%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Binary Search Template on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsamirpaulb.github.io%2fposts%2fbinary-search-template%2f&title=Binary%20Search%20Template"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Binary Search Template on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsamirpaulb.github.io%2fposts%2fbinary-search-template%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Binary Search Template on whatsapp" href="https://api.whatsapp.com/send?text=Binary%20Search%20Template%20-%20https%3a%2f%2fsamirpaulb.github.io%2fposts%2fbinary-search-template%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Binary Search Template on telegram" href="https://telegram.me/share/url?text=Binary%20Search%20Template&amp;url=https%3a%2f%2fsamirpaulb.github.io%2fposts%2fbinary-search-template%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Binary Search Template on ycombinator" href="https://news.ycombinator.com/submitlink?t=Binary%20Search%20Template&u=https%3a%2f%2fsamirpaulb.github.io%2fposts%2fbinary-search-template%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://samirpaulb.github.io/>Samir Paul</a></span>
<span>• <a href=https://samirpaulb.github.io/sitemap.xml>Sitemap</a> • <a href=https://samirpaulb.github.io/privacy>Privacy</a> • <a href=https://samirpaulb.github.io/disclaimer>Disclaimer</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script defer loading=lazy>window.addEventListener("DOMContentLoaded",function(){for(var n=document.getElementsByTagName("a"),t=0;t<n.length;t++)n[t].hostname!==window.location.hostname&&(n[t].setAttribute("target","_blank"),n[t].setAttribute("rel","noopener"))})</script><script defer loading=lazy>if("serviceWorker"in navigator){const e=!0,t=["index","next","prev","prefetch"];function prefetchCache(){if(navigator.serviceWorker.controller){let e=document.querySelectorAll(t.map(e=>"link[rel="+e+"]").join(","));e.length>0&&Array.from(e).map(e=>{let t=e.getAttribute("href");navigator.serviceWorker.controller.postMessage({action:"cache",url:t})})}}navigator.serviceWorker.register("/sw.js",{scope:"/"}).then(()=>{console.log("Service Worker Registered")}),navigator.serviceWorker.ready.then(()=>{e&&prefetchCache()})}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>