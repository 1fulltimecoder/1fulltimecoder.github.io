<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dynamic Programming on Samir Paul</title>
    <link>https://samirpaulb.github.io/tags/dynamic-programming/</link>
    <description>Recent content in Dynamic Programming on Samir Paul</description>
    <image>
      <title>Samir Paul</title>
      <url>https://spcdn.pages.dev/blog-featured-image-samirpaul-in-blog.webp</url>
      <link>https://spcdn.pages.dev/blog-featured-image-samirpaul-in-blog.webp</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 20 Jan 2021 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://samirpaulb.github.io/tags/dynamic-programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dynamic Programming Patterns</title>
      <link>https://samirpaulb.github.io/posts/dynamic-programming-patterns/</link>
      <pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://samirpaulb.github.io/posts/dynamic-programming-patterns/</guid>
      <description>Dynamic Programming Patterns</description>
      <content:encoded><![CDATA[<p><img loading="lazy" src="https://user-images.githubusercontent.com/77569653/226705479-a4d6c0a3-0191-4d45-8bf6-597ffaa5de40.png" alt="Banner"  />
</p>
<p>Before starting the topic let me introduce myself. I am a Mobile Developer currently working in Warsaw and spending my free time for interview preparations. I started to prepare for interviews two years ago. At that time I should say I could not solve the two sum problem. Easy problems seemed to me like hard ones so most of the time I had to look at editorials and discuss section. Currently, I have solved ~800 problems and time to time participate in contests. I usually solve 3 problems in a contest and sometimes 4 problems. Ok, lets come back to the topic.</p>
<p>Recently I have concentrated my attention on Dynamic Programming cause its one of the hardest topics in an interview prep. After solving ~140 problems in DP I have noticed that there are few patterns that can be found in different problems. So I did a research on that and find the following topics. I will not give complete ways how to solve problems but these patterns may be helpful in solving DP.</p>
<h1 id="patterns">Patterns</h1>
<hr>
<p><a href="https://leetcode.com/discuss/study-guide/458695/Dynamic-Programming-Patterns#Minimum-(Maximum)-Path-to-Reach-a-Target">Minimum (Maximum) Path to Reach a Target</a><br>
<a href="https://leetcode.com/discuss/study-guide/458695/Dynamic-Programming-Patterns#distinct-ways">Distinct Ways</a><br>
<a href="https://leetcode.com/discuss/study-guide/458695/Dynamic-Programming-Patterns#Merging-Intervals">Merging Intervals</a><br>
<a href="https://leetcode.com/discuss/study-guide/458695/Dynamic-Programming-Patterns#DP-on-Strings">DP on Strings</a><br>
<a href="https://leetcode.com/discuss/study-guide/458695/Dynamic-Programming-Patterns#Decision-Making">Decision Making</a></p>
<h1 id="minimum-maximum-path-to-reach-a-target">Minimum (Maximum) Path to Reach a Target</h1>
<hr>
<p>Problem list: <a href="https://leetcode.com/list/55ac4kuc">https://leetcode.com/list/55ac4kuc</a></p>
<p>Generate problem statement for this pattern</p>
<h3 id="statement">Statement</h3>
<blockquote>
<p>Given a target find minimum (maximum) cost / path / sum to reach the target.</p>
</blockquote>
<h3 id="approach">Approach</h3>
<blockquote>
<p>Choose minimum (maximum) path among all possible paths before the current state, then add value for the current state.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-0-1"><a class="lnlinks" href="#hl-0-1">1</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">routes[i] = min(routes[i-1], routes[i-2], ... , routes[i-k]) + cost[i]
</span></span></code></pre></td></tr></table>
</div>
</div><p>Generate optimal solutions for all values in the target and return the value for the target.</p>
<h3 id="top-down">Top-Down</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-1-1"><a class="lnlinks" href="#hl-1-1">1</a>
</span><span class="lnt" id="hl-1-2"><a class="lnlinks" href="#hl-1-2">2</a>
</span><span class="lnt" id="hl-1-3"><a class="lnlinks" href="#hl-1-3">3</a>
</span><span class="lnt" id="hl-1-4"><a class="lnlinks" href="#hl-1-4">4</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int j = 0; j &lt; ways.size(); ++j) {
</span></span><span class="line"><span class="cl">    result = min(result, topDown(target - ways[j]) + cost/ path / sum);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">return memo[/*state parameters*/] = result;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="bottom-up">Bottom-Up</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-2-1"><a class="lnlinks" href="#hl-2-1">1</a>
</span><span class="lnt" id="hl-2-2"><a class="lnlinks" href="#hl-2-2">2</a>
</span><span class="lnt" id="hl-2-3"><a class="lnlinks" href="#hl-2-3">3</a>
</span><span class="lnt" id="hl-2-4"><a class="lnlinks" href="#hl-2-4">4</a>
</span><span class="lnt" id="hl-2-5"><a class="lnlinks" href="#hl-2-5">5</a>
</span><span class="lnt" id="hl-2-6"><a class="lnlinks" href="#hl-2-6">6</a>
</span><span class="lnt" id="hl-2-7"><a class="lnlinks" href="#hl-2-7">7</a>
</span><span class="lnt" id="hl-2-8"><a class="lnlinks" href="#hl-2-8">8</a>
</span><span class="lnt" id="hl-2-9"><a class="lnlinks" href="#hl-2-9">9</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int i = 1; i &lt;= target; ++i) {
</span></span><span class="line"><span class="cl">   for (int j = 0; j &lt; ways.size(); ++j) {
</span></span><span class="line"><span class="cl">       if (ways[j] &lt;= i) {
</span></span><span class="line"><span class="cl">           dp[i] = min(dp[i], dp[i - ways[j]] + cost / path / sum) ;
</span></span><span class="line"><span class="cl">       }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">return dp[target]
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="similar-problems">Similar Problems</h3>
<p><a href="https://leetcode.com/problems/min-cost-climbing-stairs/">746. Min Cost Climbing Stairs</a> <code>Easy</code></p>
<h3 id="top-down-1">Top-Down</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-3-1"><a class="lnlinks" href="#hl-3-1">1</a>
</span><span class="lnt" id="hl-3-2"><a class="lnlinks" href="#hl-3-2">2</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int result = min(minCost(n-1, cost, memo), minCost(n-2, cost, memo)) + (n == cost.size() ? 0 : cost[n]);
</span></span><span class="line"><span class="cl">return memo[n] = result;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="bottom-up-1">Bottom-Up</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-4-1"><a class="lnlinks" href="#hl-4-1">1</a>
</span><span class="lnt" id="hl-4-2"><a class="lnlinks" href="#hl-4-2">2</a>
</span><span class="lnt" id="hl-4-3"><a class="lnlinks" href="#hl-4-3">3</a>
</span><span class="lnt" id="hl-4-4"><a class="lnlinks" href="#hl-4-4">4</a>
</span><span class="lnt" id="hl-4-5"><a class="lnlinks" href="#hl-4-5">5</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int i = 2; i &lt;= n; ++i) {
</span></span><span class="line"><span class="cl">   dp[i] = min(dp[i-1], dp[i-2]) + (i == n ? 0 : cost[i]);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">return dp[n]
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/minimum-path-sum/">64. Minimum Path Sum</a> <code>Medium</code></p>
<h3 id="top-down-2">Top-Down</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-5-1"><a class="lnlinks" href="#hl-5-1">1</a>
</span><span class="lnt" id="hl-5-2"><a class="lnlinks" href="#hl-5-2">2</a>
</span><span class="lnt" id="hl-5-3"><a class="lnlinks" href="#hl-5-3">3</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int result = min(pathSum(i+1, j, grid, memo), pathSum(i, j+1, grid, memo)) + grid[i][j];
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">return memo[i][j] = result;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="bottom-up-2">Bottom-Up</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-6-1"><a class="lnlinks" href="#hl-6-1">1</a>
</span><span class="lnt" id="hl-6-2"><a class="lnlinks" href="#hl-6-2">2</a>
</span><span class="lnt" id="hl-6-3"><a class="lnlinks" href="#hl-6-3">3</a>
</span><span class="lnt" id="hl-6-4"><a class="lnlinks" href="#hl-6-4">4</a>
</span><span class="lnt" id="hl-6-5"><a class="lnlinks" href="#hl-6-5">5</a>
</span><span class="lnt" id="hl-6-6"><a class="lnlinks" href="#hl-6-6">6</a>
</span><span class="lnt" id="hl-6-7"><a class="lnlinks" href="#hl-6-7">7</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int i = 1; i &lt; n; ++i) {
</span></span><span class="line"><span class="cl">   for (int j = 1; j &lt; m; ++j) {
</span></span><span class="line"><span class="cl">       grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j];
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">return grid[n-1][m-1]
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/coin-change/">322. Coin Change</a> <code>Medium</code></p>
<h3 id="top-down-3">Top-Down</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-7-1"><a class="lnlinks" href="#hl-7-1">1</a>
</span><span class="lnt" id="hl-7-2"><a class="lnlinks" href="#hl-7-2">2</a>
</span><span class="lnt" id="hl-7-3"><a class="lnlinks" href="#hl-7-3">3</a>
</span><span class="lnt" id="hl-7-4"><a class="lnlinks" href="#hl-7-4">4</a>
</span><span class="lnt" id="hl-7-5"><a class="lnlinks" href="#hl-7-5">5</a>
</span><span class="lnt" id="hl-7-6"><a class="lnlinks" href="#hl-7-6">6</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int i = 0; i &lt; coins.size(); ++i) {
</span></span><span class="line"><span class="cl">    if (coins[i] &lt;= target) { // check validity of a sub-problem
</span></span><span class="line"><span class="cl">        result = min(ans, CoinChange(target - coins[i], coins) + 1);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">return memo[target] = result;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="bottom-up-3">Bottom-Up</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-8-1"><a class="lnlinks" href="#hl-8-1">1</a>
</span><span class="lnt" id="hl-8-2"><a class="lnlinks" href="#hl-8-2">2</a>
</span><span class="lnt" id="hl-8-3"><a class="lnlinks" href="#hl-8-3">3</a>
</span><span class="lnt" id="hl-8-4"><a class="lnlinks" href="#hl-8-4">4</a>
</span><span class="lnt" id="hl-8-5"><a class="lnlinks" href="#hl-8-5">5</a>
</span><span class="lnt" id="hl-8-6"><a class="lnlinks" href="#hl-8-6">6</a>
</span><span class="lnt" id="hl-8-7"><a class="lnlinks" href="#hl-8-7">7</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int j = 1; j &lt;= amount; ++j) {
</span></span><span class="line"><span class="cl">   for (int i = 0; i &lt; coins.size(); ++i) {
</span></span><span class="line"><span class="cl">       if (coins[i] &lt;= j) {
</span></span><span class="line"><span class="cl">           dp[j] = min(dp[j], dp[j - coins[i]] + 1);
</span></span><span class="line"><span class="cl">       }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/minimum-falling-path-sum/">931. Minimum Falling Path Sum</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/minimum-cost-for-tickets/">983. Minimum Cost For Tickets</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/2-keys-keyboard/">650. 2 Keys Keyboard</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/perfect-squares/">279. Perfect Squares</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/last-stone-weight-ii/">1049. Last Stone Weight II</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/triangle/">120. Triangle</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/ones-and-zeroes/">474. Ones and Zeroes</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/maximal-square/">221. Maximal Square</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/coin-change/">322. Coin Change</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/">1240. Tiling a Rectangle with the Fewest Squares</a> <code>Hard</code></p>
<p><a href="https://leetcode.com/problems/dungeon-game/">174. Dungeon Game</a> <code>Hard</code></p>
<p><a href="https://leetcode.com/problems/minimum-number-of-refueling-stops/">871. Minimum Number of Refueling Stops</a> <code>Hard</code></p>
<h1 id="distinct-ways">Distinct Ways</h1>
<hr>
<p>Problem List: <a href="https://leetcode.com/list/55ajm50i">https://leetcode.com/list/55ajm50i</a></p>
<p>Generate problem statement for this pattern</p>
<h3 id="statement-1">Statement</h3>
<blockquote>
<p>Given a target find a number of distinct ways to reach the target.</p>
</blockquote>
<h3 id="approach-1">Approach</h3>
<blockquote>
<p>Sum all possible ways to reach the current state.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-9-1"><a class="lnlinks" href="#hl-9-1">1</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">routes[i] = routes[i-1] + routes[i-2], ... , + routes[i-k]
</span></span></code></pre></td></tr></table>
</div>
</div><p>Generate sum for all values in the target and return the value for the target.</p>
<h3 id="top-down-4">Top-Down</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-10-1"><a class="lnlinks" href="#hl-10-1">1</a>
</span><span class="lnt" id="hl-10-2"><a class="lnlinks" href="#hl-10-2">2</a>
</span><span class="lnt" id="hl-10-3"><a class="lnlinks" href="#hl-10-3">3</a>
</span><span class="lnt" id="hl-10-4"><a class="lnlinks" href="#hl-10-4">4</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int j = 0; j &lt; ways.size(); ++j) {
</span></span><span class="line"><span class="cl">    result += topDown(target - ways[j]);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">return memo[/*state parameters*/] = result;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="bottom-up-4">Bottom-Up</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-11-1"><a class="lnlinks" href="#hl-11-1">1</a>
</span><span class="lnt" id="hl-11-2"><a class="lnlinks" href="#hl-11-2">2</a>
</span><span class="lnt" id="hl-11-3"><a class="lnlinks" href="#hl-11-3">3</a>
</span><span class="lnt" id="hl-11-4"><a class="lnlinks" href="#hl-11-4">4</a>
</span><span class="lnt" id="hl-11-5"><a class="lnlinks" href="#hl-11-5">5</a>
</span><span class="lnt" id="hl-11-6"><a class="lnlinks" href="#hl-11-6">6</a>
</span><span class="lnt" id="hl-11-7"><a class="lnlinks" href="#hl-11-7">7</a>
</span><span class="lnt" id="hl-11-8"><a class="lnlinks" href="#hl-11-8">8</a>
</span><span class="lnt" id="hl-11-9"><a class="lnlinks" href="#hl-11-9">9</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int i = 1; i &lt;= target; ++i) {
</span></span><span class="line"><span class="cl">   for (int j = 0; j &lt; ways.size(); ++j) {
</span></span><span class="line"><span class="cl">       if (ways[j] &lt;= i) {
</span></span><span class="line"><span class="cl">           dp[i] += dp[i - ways[j]];
</span></span><span class="line"><span class="cl">       }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">return dp[target]
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="similar-problems-1">Similar Problems</h3>
<p><a href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs</a> <code>Easy</code></p>
<h3 id="top-down-5">Top-Down</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-12-1"><a class="lnlinks" href="#hl-12-1">1</a>
</span><span class="lnt" id="hl-12-2"><a class="lnlinks" href="#hl-12-2">2</a>
</span><span class="lnt" id="hl-12-3"><a class="lnlinks" href="#hl-12-3">3</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int result = climbStairs(n-1, memo) + climbStairs(n-2, memo); 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">return memo[n] = result;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="bottom-up-5">Bottom-Up</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-13-1"><a class="lnlinks" href="#hl-13-1">1</a>
</span><span class="lnt" id="hl-13-2"><a class="lnlinks" href="#hl-13-2">2</a>
</span><span class="lnt" id="hl-13-3"><a class="lnlinks" href="#hl-13-3">3</a>
</span><span class="lnt" id="hl-13-4"><a class="lnlinks" href="#hl-13-4">4</a>
</span><span class="lnt" id="hl-13-5"><a class="lnlinks" href="#hl-13-5">5</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int stair = 2; stair &lt;= n; ++stair) {
</span></span><span class="line"><span class="cl">   for (int step = 1; step &lt;= 2; ++step) {
</span></span><span class="line"><span class="cl">       dp[stair] += dp[stair-step];   
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/unique-paths/">62. Unique Paths</a> <code>Medium</code></p>
<h3 id="top-down-6">Top-Down</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-14-1"><a class="lnlinks" href="#hl-14-1">1</a>
</span><span class="lnt" id="hl-14-2"><a class="lnlinks" href="#hl-14-2">2</a>
</span><span class="lnt" id="hl-14-3"><a class="lnlinks" href="#hl-14-3">3</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int result = UniquePaths(x-1, y) + UniquePaths(x, y-1);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">return memo[x][y] = result;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="bottom-up-6">Bottom-Up</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-15-1"><a class="lnlinks" href="#hl-15-1">1</a>
</span><span class="lnt" id="hl-15-2"><a class="lnlinks" href="#hl-15-2">2</a>
</span><span class="lnt" id="hl-15-3"><a class="lnlinks" href="#hl-15-3">3</a>
</span><span class="lnt" id="hl-15-4"><a class="lnlinks" href="#hl-15-4">4</a>
</span><span class="lnt" id="hl-15-5"><a class="lnlinks" href="#hl-15-5">5</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int i = 1; i &lt; m; ++i) {
</span></span><span class="line"><span class="cl">   for (int j = 1; j &lt; n; ++j) {
</span></span><span class="line"><span class="cl">       dp[i][j] = dp[i][j-1] + dp[i-1][j];
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/">1155. Number of Dice Rolls With Target Sum</a> <code>Medium</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-16-1"><a class="lnlinks" href="#hl-16-1"> 1</a>
</span><span class="lnt" id="hl-16-2"><a class="lnlinks" href="#hl-16-2"> 2</a>
</span><span class="lnt" id="hl-16-3"><a class="lnlinks" href="#hl-16-3"> 3</a>
</span><span class="lnt" id="hl-16-4"><a class="lnlinks" href="#hl-16-4"> 4</a>
</span><span class="lnt" id="hl-16-5"><a class="lnlinks" href="#hl-16-5"> 5</a>
</span><span class="lnt" id="hl-16-6"><a class="lnlinks" href="#hl-16-6"> 6</a>
</span><span class="lnt" id="hl-16-7"><a class="lnlinks" href="#hl-16-7"> 7</a>
</span><span class="lnt" id="hl-16-8"><a class="lnlinks" href="#hl-16-8"> 8</a>
</span><span class="lnt" id="hl-16-9"><a class="lnlinks" href="#hl-16-9"> 9</a>
</span><span class="lnt" id="hl-16-10"><a class="lnlinks" href="#hl-16-10">10</a>
</span><span class="lnt" id="hl-16-11"><a class="lnlinks" href="#hl-16-11">11</a>
</span><span class="lnt" id="hl-16-12"><a class="lnlinks" href="#hl-16-12">12</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int rep = 1; rep &lt;= d; ++rep) {
</span></span><span class="line"><span class="cl">   vector&lt;int&gt; new_ways(target+1);
</span></span><span class="line"><span class="cl">   for (int already = 0; already &lt;= target; ++already) {
</span></span><span class="line"><span class="cl">       for (int pipe = 1; pipe &lt;= f; ++pipe) {
</span></span><span class="line"><span class="cl">           if (already - pipe &gt;= 0) {
</span></span><span class="line"><span class="cl">               new_ways[already] += ways[already - pipe];
</span></span><span class="line"><span class="cl">               new_ways[already] %= mod;
</span></span><span class="line"><span class="cl">           }
</span></span><span class="line"><span class="cl">       }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   ways = new_ways;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Note</strong></p>
<p>Some questions point out the number of repetitions, in that case, add one more loop to simulate every repetition.</p>
<p><a href="https://leetcode.com/problems/knight-probability-in-chessboard/">688. Knight Probability in Chessboard</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/target-sum/">494. Target Sum</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/combination-sum-iv/">377. Combination Sum IV</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/knight-dialer/">935. Knight Dialer</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/dice-roll-simulation/">1223. Dice Roll Simulation</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/partition-equal-subset-sum/">416. Partition Equal Subset Sum</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/soup-servings/">808. Soup Servings</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/domino-and-tromino-tiling/">790. Domino and Tromino Tiling</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/">801. Minimum Swaps To Make Sequences Increasing</a></p>
<p><a href="https://leetcode.com/problems/number-of-longest-increasing-subsequence/">673. Number of Longest Increasing Subsequence</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/unique-paths-ii/">63. Unique Paths II</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/out-of-boundary-paths/">576. Out of Boundary Paths</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/">1269. Number of Ways to Stay in the Same Place After Some Steps</a> <code>Hard</code></p>
<p><a href="https://leetcode.com/problems/count-vowels-permutation/">1220. Count Vowels Permutation</a> <code>Hard</code></p>
<h1 id="merging-intervals">Merging Intervals</h1>
<hr>
<p>Problem List: <a href="https://leetcode.com/list/55aj8s16">https://leetcode.com/list/55aj8s16</a></p>
<p>Generate problem statement for this pattern</p>
<h3 id="statement-2">Statement</h3>
<blockquote>
<p>Given a set of numbers find an optimal solution for a problem considering the current number and the best you can get from the left and right sides.</p>
</blockquote>
<h3 id="approach-2">Approach</h3>
<blockquote>
<p>Find all optimal solutions for every interval and return the best possible answer.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-17-1"><a class="lnlinks" href="#hl-17-1">1</a>
</span><span class="lnt" id="hl-17-2"><a class="lnlinks" href="#hl-17-2">2</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// from i to j
</span></span><span class="line"><span class="cl">dp[i][j] = dp[i][k] + result[k] + dp[k+1][j]
</span></span></code></pre></td></tr></table>
</div>
</div><p>Get the best from the left and right sides and add a solution for the current position.</p>
<h3 id="top-down-7">Top-Down</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-18-1"><a class="lnlinks" href="#hl-18-1">1</a>
</span><span class="lnt" id="hl-18-2"><a class="lnlinks" href="#hl-18-2">2</a>
</span><span class="lnt" id="hl-18-3"><a class="lnlinks" href="#hl-18-3">3</a>
</span><span class="lnt" id="hl-18-4"><a class="lnlinks" href="#hl-18-4">4</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int k = i; k &lt;= j; ++k) {
</span></span><span class="line"><span class="cl">    result = max(result, topDown(nums, i, k-1) + result[k] + topDown(nums, k+1, j));
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">return memo[/*state parameters*/] = result;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="bottom-up-7">Bottom-Up</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-19-1"><a class="lnlinks" href="#hl-19-1"> 1</a>
</span><span class="lnt" id="hl-19-2"><a class="lnlinks" href="#hl-19-2"> 2</a>
</span><span class="lnt" id="hl-19-3"><a class="lnlinks" href="#hl-19-3"> 3</a>
</span><span class="lnt" id="hl-19-4"><a class="lnlinks" href="#hl-19-4"> 4</a>
</span><span class="lnt" id="hl-19-5"><a class="lnlinks" href="#hl-19-5"> 5</a>
</span><span class="lnt" id="hl-19-6"><a class="lnlinks" href="#hl-19-6"> 6</a>
</span><span class="lnt" id="hl-19-7"><a class="lnlinks" href="#hl-19-7"> 7</a>
</span><span class="lnt" id="hl-19-8"><a class="lnlinks" href="#hl-19-8"> 8</a>
</span><span class="lnt" id="hl-19-9"><a class="lnlinks" href="#hl-19-9"> 9</a>
</span><span class="lnt" id="hl-19-10"><a class="lnlinks" href="#hl-19-10">10</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for(int l = 1; l&lt;n; l++) {
</span></span><span class="line"><span class="cl">   for(int i = 0; i&lt;n-l; i++) {
</span></span><span class="line"><span class="cl">       int j = i+l;
</span></span><span class="line"><span class="cl">       for(int k = i; k&lt;j; k++) {
</span></span><span class="line"><span class="cl">           dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);
</span></span><span class="line"><span class="cl">       }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">return dp[0][n-1];
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-20-1"><a class="lnlinks" href="#hl-20-1"> 1</a>
</span><span class="lnt" id="hl-20-2"><a class="lnlinks" href="#hl-20-2"> 2</a>
</span><span class="lnt" id="hl-20-3"><a class="lnlinks" href="#hl-20-3"> 3</a>
</span><span class="lnt" id="hl-20-4"><a class="lnlinks" href="#hl-20-4"> 4</a>
</span><span class="lnt" id="hl-20-5"><a class="lnlinks" href="#hl-20-5"> 5</a>
</span><span class="lnt" id="hl-20-6"><a class="lnlinks" href="#hl-20-6"> 6</a>
</span><span class="lnt" id="hl-20-7"><a class="lnlinks" href="#hl-20-7"> 7</a>
</span><span class="lnt" id="hl-20-8"><a class="lnlinks" href="#hl-20-8"> 8</a>
</span><span class="lnt" id="hl-20-9"><a class="lnlinks" href="#hl-20-9"> 9</a>
</span><span class="lnt" id="hl-20-10"><a class="lnlinks" href="#hl-20-10">10</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for(int l = 1; l&lt;n; l++) {
</span></span><span class="line"><span class="cl">   for(int i = 0; i&lt;n-l; i++) {
</span></span><span class="line"><span class="cl">       int j = i+l;
</span></span><span class="line"><span class="cl">       for(int k = i; k&lt;j; k++) {
</span></span><span class="line"><span class="cl">           dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);
</span></span><span class="line"><span class="cl">       }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">return dp[0][n-1]
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="similar-problems-2">Similar Problems</h3>
<p><a href="https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/">1130. Minimum Cost Tree From Leaf Values</a> <code>Medium</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-21-1"><a class="lnlinks" href="#hl-21-1">1</a>
</span><span class="lnt" id="hl-21-2"><a class="lnlinks" href="#hl-21-2">2</a>
</span><span class="lnt" id="hl-21-3"><a class="lnlinks" href="#hl-21-3">3</a>
</span><span class="lnt" id="hl-21-4"><a class="lnlinks" href="#hl-21-4">4</a>
</span><span class="lnt" id="hl-21-5"><a class="lnlinks" href="#hl-21-5">5</a>
</span><span class="lnt" id="hl-21-6"><a class="lnlinks" href="#hl-21-6">6</a>
</span><span class="lnt" id="hl-21-7"><a class="lnlinks" href="#hl-21-7">7</a>
</span><span class="lnt" id="hl-21-8"><a class="lnlinks" href="#hl-21-8">8</a>
</span><span class="lnt" id="hl-21-9"><a class="lnlinks" href="#hl-21-9">9</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int l = 1; l &lt; n; ++l) {
</span></span><span class="line"><span class="cl">   for (int i = 0; i &lt; n - l; ++i) {
</span></span><span class="line"><span class="cl">       int j = i + l;
</span></span><span class="line"><span class="cl">       dp[i][j] = INT_MAX;
</span></span><span class="line"><span class="cl">       for (int k = i; k &lt; j; ++k) {
</span></span><span class="line"><span class="cl">           dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxs[i][k] * maxs[k+1][j]);
</span></span><span class="line"><span class="cl">       }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/unique-binary-search-trees/">96. Unique Binary Search Trees</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/minimum-score-triangulation-of-polygon/">1039. Minimum Score Triangulation of Polygon</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/remove-boxes/">546. Remove Boxes</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/minimum-cost-to-merge-stones/">1000. Minimum Cost to Merge Stones</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/burst-balloons/">312. Burst Balloons</a> <code>Hard</code></p>
<h3 id="top-down-8">Top-Down</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-22-1"><a class="lnlinks" href="#hl-22-1">1</a>
</span><span class="lnt" id="hl-22-2"><a class="lnlinks" href="#hl-22-2">2</a>
</span><span class="lnt" id="hl-22-3"><a class="lnlinks" href="#hl-22-3">3</a>
</span><span class="lnt" id="hl-22-4"><a class="lnlinks" href="#hl-22-4">4</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int k = i; k &lt;= j; ++k) {
</span></span><span class="line"><span class="cl">    result = max(result, topDown(nums, i, k-1, memo) + (i-1 &gt;= 0 ? nums[i-1] : 1) * nums[k] * (j+1 &lt; nums.size() ? nums[j+1] : 1) + topDown(nums, k+1, j, memo));
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">return memo[i][j] = result;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="bottom-up-8">Bottom-Up</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-23-1"><a class="lnlinks" href="#hl-23-1">1</a>
</span><span class="lnt" id="hl-23-2"><a class="lnlinks" href="#hl-23-2">2</a>
</span><span class="lnt" id="hl-23-3"><a class="lnlinks" href="#hl-23-3">3</a>
</span><span class="lnt" id="hl-23-4"><a class="lnlinks" href="#hl-23-4">4</a>
</span><span class="lnt" id="hl-23-5"><a class="lnlinks" href="#hl-23-5">5</a>
</span><span class="lnt" id="hl-23-6"><a class="lnlinks" href="#hl-23-6">6</a>
</span><span class="lnt" id="hl-23-7"><a class="lnlinks" href="#hl-23-7">7</a>
</span><span class="lnt" id="hl-23-8"><a class="lnlinks" href="#hl-23-8">8</a>
</span><span class="lnt" id="hl-23-9"><a class="lnlinks" href="#hl-23-9">9</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for(int l = 1; l &lt; n; l++) {
</span></span><span class="line"><span class="cl">    for(int i = 0; i &lt; n-l; i++) {
</span></span><span class="line"><span class="cl">        int j = i+l;
</span></span><span class="line"><span class="cl">        for(int k = i; k &lt;= j; k++) {
</span></span><span class="line"><span class="cl">            dp[i][j] = max(dp[i][j], (((k&gt;i &amp;&amp; k&gt;0) ? dp[i][k-1] : 0) + (i&gt;0 ? nums[i-1] : 1) * nums[k] * (j&lt;n-1 ? nums[j+1] : 1) + ((k&lt;j &amp;&amp; k&lt;n-1) ? dp[k+1][j] : 0)));
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">return dp[0][n-1];
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/guess-number-higher-or-lower-ii/">375. Guess Number Higher or Lower II</a> <code>Medium</code></p>
<h1 id="dp-on-strings">DP on Strings</h1>
<hr>
<p>Problem List: <a href="https://leetcode.com/list/55afh7m7">https://leetcode.com/list/55afh7m7</a></p>
<p>General problem statement for this pattern can vary but most of the time you are given two strings where lengths of those strings are not big</p>
<h3 id="statement-3">Statement</h3>
<blockquote>
<p>Given two strings <code>s1</code> and <code>s2</code>, return <code>some result</code>.</p>
</blockquote>
<h3 id="approach-3">Approach</h3>
<blockquote>
<p>Most of the problems on this pattern requires a solution that can be accepted in O(n^2) complexity.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-24-1"><a class="lnlinks" href="#hl-24-1"> 1</a>
</span><span class="lnt" id="hl-24-2"><a class="lnlinks" href="#hl-24-2"> 2</a>
</span><span class="lnt" id="hl-24-3"><a class="lnlinks" href="#hl-24-3"> 3</a>
</span><span class="lnt" id="hl-24-4"><a class="lnlinks" href="#hl-24-4"> 4</a>
</span><span class="lnt" id="hl-24-5"><a class="lnlinks" href="#hl-24-5"> 5</a>
</span><span class="lnt" id="hl-24-6"><a class="lnlinks" href="#hl-24-6"> 6</a>
</span><span class="lnt" id="hl-24-7"><a class="lnlinks" href="#hl-24-7"> 7</a>
</span><span class="lnt" id="hl-24-8"><a class="lnlinks" href="#hl-24-8"> 8</a>
</span><span class="lnt" id="hl-24-9"><a class="lnlinks" href="#hl-24-9"> 9</a>
</span><span class="lnt" id="hl-24-10"><a class="lnlinks" href="#hl-24-10">10</a>
</span><span class="lnt" id="hl-24-11"><a class="lnlinks" href="#hl-24-11">11</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// i - indexing string s1
</span></span><span class="line"><span class="cl">// j - indexing string s2
</span></span><span class="line"><span class="cl">for (int i = 1; i &lt;= n; ++i) {
</span></span><span class="line"><span class="cl">   for (int j = 1; j &lt;= m; ++j) {
</span></span><span class="line"><span class="cl">       if (s1[i-1] == s2[j-1]) {
</span></span><span class="line"><span class="cl">           dp[i][j] = /*code*/;
</span></span><span class="line"><span class="cl">       } else {
</span></span><span class="line"><span class="cl">           dp[i][j] = /*code*/;
</span></span><span class="line"><span class="cl">       }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>If you are given one string <code>s</code> the approach may little vary</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-25-1"><a class="lnlinks" href="#hl-25-1"> 1</a>
</span><span class="lnt" id="hl-25-2"><a class="lnlinks" href="#hl-25-2"> 2</a>
</span><span class="lnt" id="hl-25-3"><a class="lnlinks" href="#hl-25-3"> 3</a>
</span><span class="lnt" id="hl-25-4"><a class="lnlinks" href="#hl-25-4"> 4</a>
</span><span class="lnt" id="hl-25-5"><a class="lnlinks" href="#hl-25-5"> 5</a>
</span><span class="lnt" id="hl-25-6"><a class="lnlinks" href="#hl-25-6"> 6</a>
</span><span class="lnt" id="hl-25-7"><a class="lnlinks" href="#hl-25-7"> 7</a>
</span><span class="lnt" id="hl-25-8"><a class="lnlinks" href="#hl-25-8"> 8</a>
</span><span class="lnt" id="hl-25-9"><a class="lnlinks" href="#hl-25-9"> 9</a>
</span><span class="lnt" id="hl-25-10"><a class="lnlinks" href="#hl-25-10">10</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int l = 1; l &lt; n; ++l) {
</span></span><span class="line"><span class="cl">   for (int i = 0; i &lt; n-l; ++i) {
</span></span><span class="line"><span class="cl">       int j = i + l;
</span></span><span class="line"><span class="cl">       if (s[i] == s[j]) {
</span></span><span class="line"><span class="cl">           dp[i][j] = /*code*/;
</span></span><span class="line"><span class="cl">       } else {
</span></span><span class="line"><span class="cl">           dp[i][j] = /*code*/;
</span></span><span class="line"><span class="cl">       }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/longest-common-subsequence/">1143. Longest Common Subsequence</a> <code>Medium</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-26-1"><a class="lnlinks" href="#hl-26-1">1</a>
</span><span class="lnt" id="hl-26-2"><a class="lnlinks" href="#hl-26-2">2</a>
</span><span class="lnt" id="hl-26-3"><a class="lnlinks" href="#hl-26-3">3</a>
</span><span class="lnt" id="hl-26-4"><a class="lnlinks" href="#hl-26-4">4</a>
</span><span class="lnt" id="hl-26-5"><a class="lnlinks" href="#hl-26-5">5</a>
</span><span class="lnt" id="hl-26-6"><a class="lnlinks" href="#hl-26-6">6</a>
</span><span class="lnt" id="hl-26-7"><a class="lnlinks" href="#hl-26-7">7</a>
</span><span class="lnt" id="hl-26-8"><a class="lnlinks" href="#hl-26-8">8</a>
</span><span class="lnt" id="hl-26-9"><a class="lnlinks" href="#hl-26-9">9</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int i = 1; i &lt;= n; ++i) {
</span></span><span class="line"><span class="cl">   for (int j = 1; j &lt;= m; ++j) {
</span></span><span class="line"><span class="cl">       if (text1[i-1] == text2[j-1]) {
</span></span><span class="line"><span class="cl">           dp[i][j] = dp[i-1][j-1] + 1;
</span></span><span class="line"><span class="cl">       } else {
</span></span><span class="line"><span class="cl">           dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
</span></span><span class="line"><span class="cl">       }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/palindromic-substrings/">647. Palindromic Substrings</a> <code>Medium</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-27-1"><a class="lnlinks" href="#hl-27-1"> 1</a>
</span><span class="lnt" id="hl-27-2"><a class="lnlinks" href="#hl-27-2"> 2</a>
</span><span class="lnt" id="hl-27-3"><a class="lnlinks" href="#hl-27-3"> 3</a>
</span><span class="lnt" id="hl-27-4"><a class="lnlinks" href="#hl-27-4"> 4</a>
</span><span class="lnt" id="hl-27-5"><a class="lnlinks" href="#hl-27-5"> 5</a>
</span><span class="lnt" id="hl-27-6"><a class="lnlinks" href="#hl-27-6"> 6</a>
</span><span class="lnt" id="hl-27-7"><a class="lnlinks" href="#hl-27-7"> 7</a>
</span><span class="lnt" id="hl-27-8"><a class="lnlinks" href="#hl-27-8"> 8</a>
</span><span class="lnt" id="hl-27-9"><a class="lnlinks" href="#hl-27-9"> 9</a>
</span><span class="lnt" id="hl-27-10"><a class="lnlinks" href="#hl-27-10">10</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int l = 1; l &lt; n; ++l) {
</span></span><span class="line"><span class="cl">   for (int i = 0; i &lt; n-l; ++i) {
</span></span><span class="line"><span class="cl">       int j = i + l;
</span></span><span class="line"><span class="cl">       if (s[i] == s[j] &amp;&amp; dp[i+1][j-1] == j-i-1) {
</span></span><span class="line"><span class="cl">           dp[i][j] = dp[i+1][j-1] + 2;
</span></span><span class="line"><span class="cl">       } else {
</span></span><span class="line"><span class="cl">           dp[i][j] = 0;
</span></span><span class="line"><span class="cl">       }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/longest-palindromic-subsequence/">516. Longest Palindromic Subsequence</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/shortest-common-supersequence/">1092. Shortest Common Supersequence</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/edit-distance/">72. Edit Distance</a> <code>Hard</code></p>
<p><a href="https://leetcode.com/problems/distinct-subsequences/">115. Distinct Subsequences</a> <code>Hard</code></p>
<p><a href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/">712. Minimum ASCII Delete Sum for Two Strings</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a> <code>Medium</code></p>
<h1 id="decision-making">Decision Making</h1>
<hr>
<p>Problem List: <a href="https://leetcode.com/list/55af7bu7">https://leetcode.com/list/55af7bu7</a></p>
<p>The general problem statement for this pattern is forgiven situation decide whether to use or not to use the current state. So, the problem requires you to make a decision at a current state.</p>
<h3 id="statement-4">Statement</h3>
<blockquote>
<p>Given a set of values find an answer with an option to choose or ignore the current value.</p>
</blockquote>
<h3 id="approach-4">Approach</h3>
<blockquote>
<p>If you decide to choose the current value use the previous result where the value was ignored; vice-versa, if you decide to ignore the current value use previous result where value was used.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-28-1"><a class="lnlinks" href="#hl-28-1">1</a>
</span><span class="lnt" id="hl-28-2"><a class="lnlinks" href="#hl-28-2">2</a>
</span><span class="lnt" id="hl-28-3"><a class="lnlinks" href="#hl-28-3">3</a>
</span><span class="lnt" id="hl-28-4"><a class="lnlinks" href="#hl-28-4">4</a>
</span><span class="lnt" id="hl-28-5"><a class="lnlinks" href="#hl-28-5">5</a>
</span><span class="lnt" id="hl-28-6"><a class="lnlinks" href="#hl-28-6">6</a>
</span><span class="lnt" id="hl-28-7"><a class="lnlinks" href="#hl-28-7">7</a>
</span><span class="lnt" id="hl-28-8"><a class="lnlinks" href="#hl-28-8">8</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// i - indexing a set of values
</span></span><span class="line"><span class="cl">// j - options to ignore j values
</span></span><span class="line"><span class="cl">for (int i = 1; i &lt; n; ++i) {
</span></span><span class="line"><span class="cl">   for (int j = 1; j &lt;= k; ++j) {
</span></span><span class="line"><span class="cl">       dp[i][j] = max({dp[i][j], dp[i-1][j] + arr[i], dp[i-1][j-1]});
</span></span><span class="line"><span class="cl">       dp[i][j-1] = max({dp[i][j-1], dp[i-1][j-1] + arr[i], arr[i]});
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/house-robber/">198. House Robber</a> <code>Easy</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-29-1"><a class="lnlinks" href="#hl-29-1">1</a>
</span><span class="lnt" id="hl-29-2"><a class="lnlinks" href="#hl-29-2">2</a>
</span><span class="lnt" id="hl-29-3"><a class="lnlinks" href="#hl-29-3">3</a>
</span><span class="lnt" id="hl-29-4"><a class="lnlinks" href="#hl-29-4">4</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int i = 1; i &lt; n; ++i) {
</span></span><span class="line"><span class="cl">   dp[i][1] = max(dp[i-1][0] + nums[i], dp[i-1][1]);
</span></span><span class="line"><span class="cl">   dp[i][0] = dp[i-1][1];
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">121. Best Time to Buy and Sell Stock</a> <code>Easy</code></p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. Best Time to Buy and Sell Stock with Transaction Fee</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. Best Time to Buy and Sell Stock with Cooldown</a> <code>Medium</code></p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">123. Best Time to Buy and Sell Stock III</a> <code>Hard</code></p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">188. Best Time to Buy and Sell Stock IV</a> <code>Hard</code></p>
<p>I hope these tips will be helpful 😊</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
